#include <furi.h>
#include <furi_hal.h>
#include <furi_hal_serial.h>
#include <furi_hal_usb_cdc.h>
#include <gui/gui.h>
#include <gui/view_dispatcher.h>
#include <gui/modules/text_box.h>
#include <notification/notification_messages.h>
#include <furi_hal_gpio.h>
#include <furi_hal_subghz.h>

#define UART_CH (FuriHalSerialIdUsart)
#define RX_BUFFER_SIZE 256

typedef struct {
    ViewDispatcher* view_dispatcher;
    TextBox* text_box;
    FuriString* text_buffer;
    NotificationApp* notifications;
    FuriHalSerialHandle* serial_handle;
    FuriStreamBuffer* rx_stream;
    FuriThread* worker_thread;
    bool running;
    bool subghz_active;
} PentestApp;

// ==================== SERIAL COMMUNICATION ====================

static void usb_rx_callback(FuriHalSerialHandle* handle, FuriHalSerialRxEvent event, void* context) {
    PentestApp* app = context;
    if(event == FuriHalSerialRxEventData) {
        uint8_t data = furi_hal_serial_async_rx(handle);
        furi_stream_buffer_send(app->rx_stream, &data, 1, 0);
    }
}

static void send_response(PentestApp* app, const char* response) {
    size_t len = strlen(response);
    furi_hal_serial_tx(app->serial_handle, (uint8_t*)response, len);
    furi_hal_serial_tx(app->serial_handle, (uint8_t*)"\r\n", 2);
    furi_string_cat_printf(app->text_buffer, "TX: %s\n", response);
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

// ==================== SUBGHZ MODULE ====================

static void handle_subghz_rx(PentestApp* app, uint32_t frequency) {
    if(!furi_hal_subghz_is_frequency_valid(frequency)) {
        send_response(app, "ERROR|Invalid frequency");
        return;
    }
    furi_hal_subghz_reset();
    furi_hal_subghz_load_preset(FuriHalSubGhzPresetOok650Async);
    furi_hal_subghz_set_frequency(frequency);
    furi_hal_subghz_flush_rx();
    furi_hal_subghz_start_async_rx(NULL, NULL);
    app->subghz_active = true;
    send_response(app, "OK|SubGHz RX started");
    furi_string_cat_printf(app->text_buffer, "SubGHz RX: %lu Hz\n", frequency);
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

static void handle_subghz_stop(PentestApp* app) {
    if(app->subghz_active) {
        furi_hal_subghz_stop_async_rx();
        furi_hal_subghz_sleep();
        app->subghz_active = false;
    }
    send_response(app, "OK|SubGHz stopped");
}

// ==================== GPIO MODULE ====================

static void handle_gpio_read(PentestApp* app, uint8_t pin) {
    const GpioPin* gpio_pin = NULL;
    switch(pin) {
        case 2: gpio_pin = &gpio_ext_pa7; break;
        case 3: gpio_pin = &gpio_ext_pa6; break;
        case 4: gpio_pin = &gpio_ext_pa4; break;
        case 5: gpio_pin = &gpio_ext_pb3; break;
        case 6: gpio_pin = &gpio_ext_pb2; break;
        case 7: gpio_pin = &gpio_ext_pc3; break;
        default:
            send_response(app, "ERROR|Invalid pin");
            return;
    }
    furi_hal_gpio_init_simple(gpio_pin, GpioModeInput);
    bool state = furi_hal_gpio_read(gpio_pin);
    char response[64];
    snprintf(response, sizeof(response), "GPIO_READ|pin:%d,state:%s", pin, state ? "HIGH" : "LOW");
    send_response(app, response);
    furi_string_cat_printf(app->text_buffer, "GPIO%d: %s\n", pin, state ? "HIGH" : "LOW");
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

static void handle_gpio_write(PentestApp* app, uint8_t pin, bool state) {
    const GpioPin* gpio_pin = NULL;
    switch(pin) {
        case 2: gpio_pin = &gpio_ext_pa7; break;
        case 3: gpio_pin = &gpio_ext_pa6; break;
        case 4: gpio_pin = &gpio_ext_pa4; break;
        case 5: gpio_pin = &gpio_ext_pb3; break;
        case 6: gpio_pin = &gpio_ext_pb2; break;
        case 7: gpio_pin = &gpio_ext_pc3; break;
        default:
            send_response(app, "ERROR|Invalid pin");
            return;
    }
    furi_hal_gpio_init_simple(gpio_pin, GpioModeOutputPushPull);
    furi_hal_gpio_write(gpio_pin, state);
    char response[64];
    snprintf(response, sizeof(response), "GPIO_WRITE|pin:%d,state:%s", pin, state ? "HIGH" : "LOW");
    send_response(app, response);
    furi_string_cat_printf(app->text_buffer, "GPIO%d = %s\n", pin, state ? "HIGH" : "LOW");
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

// ==================== COMMAND PARSER ====================

static void parse_command(PentestApp* app, const char* cmd) {
    furi_string_cat_printf(app->text_buffer, "RX: %s\n", cmd);

    // SubGHz commands
    if(strncmp(cmd, "subghz rx ", 10) == 0) {
        uint32_t freq = atol(cmd + 10);
        handle_subghz_rx(app, freq);
    }
    else if(strcmp(cmd, "subghz stop") == 0) {
        handle_subghz_stop(app);
    }

    // GPIO commands
    else if(strncmp(cmd, "gpio read ", 10) == 0) {
        uint8_t pin = atoi(cmd + 10);
        handle_gpio_read(app, pin);
    }
    else if(strncmp(cmd, "gpio write ", 11) == 0) {
        char* space = strchr(cmd + 11, ' ');
        if(space) {
            uint8_t pin = atoi(cmd + 11);
            bool state = atoi(space + 1);
            handle_gpio_write(app, pin, state);
        }
    }

    // Device info
    else if(strcmp(cmd, "device_info") == 0) {
        char response[128];
        snprintf(response, sizeof(response),
                "DEVICE_INFO|name:Flipper,version:%s,firmware:Unleashed,target:%d",
                furi_hal_version_get_name_ptr(),
                furi_hal_version_get_hw_target());
        send_response(app, response);
    }

    // RFID/NFC/IR/iButton - Use built-in apps
    else if(strstr(cmd, "rfid") || strstr(cmd, "nfc") || strstr(cmd, "ir ") || strstr(cmd, "ibutton")) {
        send_response(app, "FEATURE|Use Flipper built-in apps - Android can launch them");
    }

    // Unknown command
    else {
        char response[64];
        snprintf(response, sizeof(response), "ERROR|Unknown command: %s", cmd);
        send_response(app, response);
    }

    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

// ==================== WORKER THREAD ====================

static int32_t worker_thread(void* context) {
    PentestApp* app = context;
    char rx_buffer[RX_BUFFER_SIZE];
    size_t rx_index = 0;

    while(app->running) {
        uint8_t byte;
        if(furi_stream_buffer_receive(app->rx_stream, &byte, 1, 100) > 0) {
            if(byte == '\n' || byte == '\r') {
                if(rx_index > 0) {
                    rx_buffer[rx_index] = '\0';
                    parse_command(app, rx_buffer);
                    rx_index = 0;
                }
            } else if(rx_index < RX_BUFFER_SIZE - 1) {
                rx_buffer[rx_index++] = byte;
            }
        }
    }
    return 0;
}

// ==================== APP LIFECYCLE ====================

static PentestApp* app_alloc() {
    PentestApp* app = malloc(sizeof(PentestApp));
    app->text_buffer = furi_string_alloc();
    furi_string_printf(app->text_buffer, "Pentest Companion v2.0\nUnleashed Firmware\nReady for commands\n");

    app->view_dispatcher = view_dispatcher_alloc();
    app->text_box = text_box_alloc();
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
    text_box_set_font(app->text_box, TextBoxFontText);
    view_dispatcher_add_view(app->view_dispatcher, 0, text_box_get_view(app->text_box));

    Gui* gui = furi_record_open(RECORD_GUI);
    view_dispatcher_attach_to_gui(app->view_dispatcher, gui, ViewDispatcherTypeFullscreen);
    view_dispatcher_switch_to_view(app->view_dispatcher, 0);

    app->notifications = furi_record_open(RECORD_NOTIFICATION);

    app->rx_stream = furi_stream_buffer_alloc(RX_BUFFER_SIZE, 1);
    app->serial_handle = furi_hal_serial_control_acquire(UART_CH);
    furi_hal_serial_init(app->serial_handle, 115200);
    furi_hal_serial_async_rx_start(app->serial_handle, usb_rx_callback, app, false);

    app->running = true;
    app->subghz_active = false;
    app->worker_thread = furi_thread_alloc();
    furi_thread_set_name(app->worker_thread, "PentestWorker");
    furi_thread_set_stack_size(app->worker_thread, 2048);
    furi_thread_set_context(app->worker_thread, app);
    furi_thread_set_callback(app->worker_thread, worker_thread);
    furi_thread_start(app->worker_thread);

    notification_message(app->notifications, &sequence_success);
    return app;
}

static void app_free(PentestApp* app) {
    app->running = false;
    furi_thread_join(app->worker_thread);
    furi_thread_free(app->worker_thread);

    if(app->subghz_active) {
        furi_hal_subghz_stop_async_rx();
        furi_hal_subghz_sleep();
    }

    furi_hal_serial_async_rx_stop(app->serial_handle);
    furi_hal_serial_deinit(app->serial_handle);
    furi_hal_serial_control_release(app->serial_handle);
    furi_stream_buffer_free(app->rx_stream);

    view_dispatcher_remove_view(app->view_dispatcher, 0);
    text_box_free(app->text_box);
    view_dispatcher_free(app->view_dispatcher);

    furi_record_close(RECORD_NOTIFICATION);
    furi_record_close(RECORD_GUI);

    furi_string_free(app->text_buffer);
    free(app);
}

int32_t pentest_companion_app(void* p) {
    UNUSED(p);
    PentestApp* app = app_alloc();
    view_dispatcher_run(app->view_dispatcher);
    app_free(app);
    return 0;
}
