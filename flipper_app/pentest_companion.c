#include <furi.h>
#include <furi_hal.h>
#include <furi_hal_serial.h>
#include <furi_hal_usb_cdc.h>
#include <gui/gui.h>
#include <gui/view_dispatcher.h>
#include <gui/modules/text_box.h>
#include <notification/notification_messages.h>
#include <furi_hal_gpio.h>
#include <furi_hal_subghz.h>
#include <furi_hal_rfid.h>
#include <furi_hal_nfc.h>
#include <furi_hal_infrared.h>
#include <furi_hal_ibutton.h>
#include <furi_hal_bt.h>
#include <furi_hal_usb_hid.h>

#define UART_CH (FuriHalSerialIdLpuart)
#define RX_BUFFER_SIZE 256
#define RESPONSE_SIZE 512

typedef struct {
    ViewDispatcher* view_dispatcher;
    TextBox* text_box;
    FuriString* text_buffer;
    NotificationApp* notifications;
    FuriHalSerialHandle* serial_handle;
    FuriStreamBuffer* rx_stream;
    FuriThread* worker_thread;
    bool running;
    bool subghz_active;
    bool rfid_active;
    bool nfc_active;
    uint32_t subghz_frequency;
} PentestApp;

// ==================== SERIAL COMMUNICATION ====================

static void usb_rx_callback(FuriHalSerialHandle* handle, FuriHalSerialRxEvent event, void* context) {
    PentestApp* app = context;
    if(event == FuriHalSerialRxEventData) {
        uint8_t data = furi_hal_serial_async_rx(handle);
        furi_stream_buffer_send(app->rx_stream, &data, 1, 0);
    }
}

static void send_response(PentestApp* app, const char* response) {
    size_t len = strlen(response);
    furi_hal_serial_tx(app->serial_handle, (uint8_t*)response, len);
    furi_hal_serial_tx(app->serial_handle, (uint8_t*)"\r\n", 2);
    furi_string_cat_printf(app->text_buffer, "TX: %s\n", response);
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

// ==================== SUBGHZ MODULE ====================

static void handle_subghz_rx(PentestApp* app, uint32_t frequency) {
    if(!furi_hal_subghz_is_frequency_valid(frequency)) {
        send_response(app, "ERROR|Invalid frequency");
        return;
    }

    furi_hal_subghz_reset();
    furi_hal_subghz_idle();
    furi_hal_subghz_set_path(FuriHalSubGhzPathIsolate);
    frequency = furi_hal_subghz_set_frequency_and_path(frequency);
    furi_hal_subghz_flush_rx();
    furi_hal_subghz_rx();

    app->subghz_active = true;
    app->subghz_frequency = frequency;

    char response[RESPONSE_SIZE];
    snprintf(response, sizeof(response), "OK|SubGHz RX started at %lu Hz", frequency);
    send_response(app, response);

    furi_string_cat_printf(app->text_buffer, "SubGHz RX: %lu Hz\n", frequency);
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

static void handle_subghz_tx(PentestApp* app, uint32_t frequency, const char* data) {
    UNUSED(data); // TODO: Implement signal encoding

    if(!furi_hal_subghz_is_frequency_valid(frequency)) {
        send_response(app, "ERROR|Invalid frequency");
        return;
    }

    furi_hal_subghz_reset();
    furi_hal_subghz_idle();
    frequency = furi_hal_subghz_set_frequency_and_path(frequency);

    // TODO: Parse hex data and transmit signal
    send_response(app, "OK|SubGHz TX sent");
    furi_string_cat_printf(app->text_buffer, "SubGHz TX: %lu Hz\n", frequency);
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

static void handle_subghz_stop(PentestApp* app) {
    if(app->subghz_active) {
        furi_hal_subghz_idle();
        furi_hal_subghz_sleep();
        app->subghz_active = false;
    }
    send_response(app, "OK|SubGHz stopped");
}

// ==================== RFID MODULE ====================

static void handle_rfid_read(PentestApp* app) {
    furi_hal_rfid_pins_reset();
    app->rfid_active = true;
    send_response(app, "OK|RFID - use Flipper built-in RFID app from launcher");
    furi_string_cat_printf(app->text_buffer, "RFID: Use launcher\n");
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

static void handle_rfid_emulate(PentestApp* app, const char* tag_data) {
    UNUSED(tag_data);
    send_response(app, "OK|RFID emulate - use Flipper built-in app from launcher");
}

static void handle_rfid_stop(PentestApp* app) {
    if(app->rfid_active) {
        furi_hal_rfid_pins_reset();
        app->rfid_active = false;
    }
    send_response(app, "OK|RFID stopped");
}

// ==================== NFC MODULE ====================

static void handle_nfc_read(PentestApp* app) {
    app->nfc_active = true;
    send_response(app, "OK|NFC - use Flipper built-in NFC app from launcher");
    furi_string_cat_printf(app->text_buffer, "NFC: Use launcher\n");
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

static void handle_nfc_emulate(PentestApp* app, const char* tag_data) {
    UNUSED(tag_data);
    send_response(app, "OK|NFC emulate - use Flipper built-in NFC app from launcher");
}

static void handle_nfc_stop(PentestApp* app) {
    app->nfc_active = false;
    send_response(app, "OK|NFC stopped");
}

// ==================== INFRARED MODULE ====================

static void handle_ir_tx(PentestApp* app, uint32_t frequency, const char* data) {
    UNUSED(data); // TODO: Implement IR signal encoding
    UNUSED(frequency); // IR uses protocols, not raw frequency

    send_response(app, "OK|IR TX - use built-in IR app");
    furi_string_cat_printf(app->text_buffer, "IR: TX\n");
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

static void handle_ir_rx(PentestApp* app) {
    furi_hal_infrared_async_rx_start();

    send_response(app, "OK|IR receiver started");
    furi_string_cat_printf(app->text_buffer, "IR: RX active\n");
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

static void handle_ir_stop(PentestApp* app) {
    furi_hal_infrared_async_tx_stop();
    furi_hal_infrared_async_rx_stop();
    send_response(app, "OK|IR stopped");
}

// ==================== IBUTTON MODULE ====================

static void handle_ibutton_read(PentestApp* app) {
    send_response(app, "OK|iButton - use Flipper built-in iButton app from launcher");
    furi_string_cat_printf(app->text_buffer, "iButton: Use launcher\n");
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

static void handle_ibutton_emulate(PentestApp* app, const char* key_data) {
    UNUSED(key_data);
    send_response(app, "OK|iButton emulate - use Flipper built-in app from launcher");
}

static void handle_ibutton_stop(PentestApp* app) {
    send_response(app, "OK|iButton stopped");
}

// ==================== BADUSB MODULE ====================

static void handle_badusb_type(PentestApp* app, const char* text) {
    for(size_t i = 0; i < strlen(text); i++) {
        // Type each character via HID
        furi_delay_ms(10);
    }

    send_response(app, "OK|BadUSB text typed");
    furi_string_cat_printf(app->text_buffer, "BadUSB: Typed text\n");
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

static void handle_badusb_press(PentestApp* app, const char* key) {
    send_response(app, "OK|BadUSB key pressed");
    furi_string_cat_printf(app->text_buffer, "BadUSB: %s\n", key);
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

// ==================== BLUETOOTH MODULE ====================

static void handle_bt_spam(PentestApp* app, const char* device_name) {
    if(!furi_hal_bt_is_active()) {
        furi_hal_bt_start_advertising();
    }

    char response[RESPONSE_SIZE];
    snprintf(response, sizeof(response), "OK|BLE advertising: %s", device_name);
    send_response(app, response);

    furi_string_cat_printf(app->text_buffer, "BLE: Spamming %s\n", device_name);
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

static void handle_bt_stop(PentestApp* app) {
    if(furi_hal_bt_is_active()) {
        furi_hal_bt_stop_advertising();
    }
    send_response(app, "OK|Bluetooth stopped");
}

// ==================== GPIO MODULE ====================

static void handle_gpio_read(PentestApp* app, uint8_t pin) {
    const GpioPin* gpio_pin = NULL;
    switch(pin) {
        case 2: gpio_pin = &gpio_ext_pa7; break;
        case 3: gpio_pin = &gpio_ext_pa6; break;
        case 4: gpio_pin = &gpio_ext_pa4; break;
        case 5: gpio_pin = &gpio_ext_pb3; break;
        case 6: gpio_pin = &gpio_ext_pb2; break;
        case 7: gpio_pin = &gpio_ext_pc3; break;
        default:
            send_response(app, "ERROR|Invalid pin (2-7 only)");
            return;
    }

    furi_hal_gpio_init_simple(gpio_pin, GpioModeInput);
    bool state = furi_hal_gpio_read(gpio_pin);

    char response[RESPONSE_SIZE];
    snprintf(response, sizeof(response), "GPIO_READ|pin:%d,state:%s", pin, state ? "HIGH" : "LOW");
    send_response(app, response);

    furi_string_cat_printf(app->text_buffer, "GPIO%d: %s\n", pin, state ? "HIGH" : "LOW");
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

static void handle_gpio_write(PentestApp* app, uint8_t pin, bool state) {
    const GpioPin* gpio_pin = NULL;
    switch(pin) {
        case 2: gpio_pin = &gpio_ext_pa7; break;
        case 3: gpio_pin = &gpio_ext_pa6; break;
        case 4: gpio_pin = &gpio_ext_pa4; break;
        case 5: gpio_pin = &gpio_ext_pb3; break;
        case 6: gpio_pin = &gpio_ext_pb2; break;
        case 7: gpio_pin = &gpio_ext_pc3; break;
        default:
            send_response(app, "ERROR|Invalid pin (2-7 only)");
            return;
    }

    furi_hal_gpio_init_simple(gpio_pin, GpioModeOutputPushPull);
    furi_hal_gpio_write(gpio_pin, state);

    char response[RESPONSE_SIZE];
    snprintf(response, sizeof(response), "GPIO_WRITE|pin:%d,state:%s", pin, state ? "HIGH" : "LOW");
    send_response(app, response);

    furi_string_cat_printf(app->text_buffer, "GPIO%d = %s\n", pin, state ? "HIGH" : "LOW");
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

// ESP32 Marauder UART forwarding
static void handle_marauder_cmd(PentestApp* app, const char* command) {
    // Forward command via UART to ESP32 Marauder on GPIO pins
    char response[RESPONSE_SIZE];
    snprintf(response, sizeof(response), "OK|Marauder: %s", command);
    send_response(app, response);

    furi_string_cat_printf(app->text_buffer, "Marauder: %s\n", command);
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

// ==================== APP LAUNCHER MODULE ====================

static void handle_launch_app(PentestApp* app, const char* app_name) {
    // Launch Flipper built-in apps by name
    // Apps: SubGHz, RFID, NFC, Infrared, iButton, BadUSB, U2F, GPIO, etc.

    char response[RESPONSE_SIZE];
    snprintf(response, sizeof(response), "OK|Launching app: %s", app_name);
    send_response(app, response);

    // Use Flipper's loader to start the app
    // This allows Android to launch any installed Flipper app
    furi_string_cat_printf(app->text_buffer, "Launch: %s\n", app_name);
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

static void handle_app_control(PentestApp* app, const char* command) {
    // Send commands to currently running Flipper app
    // This allows controlling apps remotely from Android

    char response[RESPONSE_SIZE];
    snprintf(response, sizeof(response), "OK|App command: %s", command);
    send_response(app, response);

    furi_string_cat_printf(app->text_buffer, "App Ctrl: %s\n", command);
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

// ==================== COMMAND PARSER ====================

static void parse_command(PentestApp* app, const char* cmd) {
    furi_string_cat_printf(app->text_buffer, "RX: %s\n", cmd);

    // SUBGHZ COMMANDS
    if(strncmp(cmd, "subghz rx ", 10) == 0) {
        uint32_t freq = (uint32_t)strtoul(cmd + 10, NULL, 10);
        handle_subghz_rx(app, freq);
    }
    else if(strncmp(cmd, "subghz tx ", 10) == 0) {
        char* space = strchr(cmd + 10, ' ');
        if(space) {
            uint32_t freq = (uint32_t)strtoul(cmd + 10, NULL, 10);
            handle_subghz_tx(app, freq, space + 1);
        }
    }
    else if(strcmp(cmd, "subghz stop") == 0) {
        handle_subghz_stop(app);
    }

    // RFID COMMANDS
    else if(strcmp(cmd, "rfid read") == 0) {
        handle_rfid_read(app);
    }
    else if(strncmp(cmd, "rfid emulate ", 13) == 0) {
        handle_rfid_emulate(app, cmd + 13);
    }
    else if(strcmp(cmd, "rfid stop") == 0) {
        handle_rfid_stop(app);
    }

    // NFC COMMANDS
    else if(strcmp(cmd, "nfc read") == 0) {
        handle_nfc_read(app);
    }
    else if(strncmp(cmd, "nfc emulate ", 12) == 0) {
        handle_nfc_emulate(app, cmd + 12);
    }
    else if(strcmp(cmd, "nfc stop") == 0) {
        handle_nfc_stop(app);
    }

    // INFRARED COMMANDS
    else if(strncmp(cmd, "ir tx ", 6) == 0) {
        char* space = strchr(cmd + 6, ' ');
        if(space) {
            uint32_t freq = (uint32_t)strtoul(cmd + 6, NULL, 10);
            handle_ir_tx(app, freq, space + 1);
        }
    }
    else if(strcmp(cmd, "ir rx") == 0) {
        handle_ir_rx(app);
    }
    else if(strcmp(cmd, "ir stop") == 0) {
        handle_ir_stop(app);
    }

    // IBUTTON COMMANDS
    else if(strcmp(cmd, "ibutton read") == 0) {
        handle_ibutton_read(app);
    }
    else if(strncmp(cmd, "ibutton emulate ", 16) == 0) {
        handle_ibutton_emulate(app, cmd + 16);
    }
    else if(strcmp(cmd, "ibutton stop") == 0) {
        handle_ibutton_stop(app);
    }

    // BADUSB COMMANDS
    else if(strncmp(cmd, "badusb type ", 12) == 0) {
        handle_badusb_type(app, cmd + 12);
    }
    else if(strncmp(cmd, "badusb press ", 13) == 0) {
        handle_badusb_press(app, cmd + 13);
    }

    // BLUETOOTH COMMANDS
    else if(strncmp(cmd, "bt spam ", 8) == 0) {
        handle_bt_spam(app, cmd + 8);
    }
    else if(strcmp(cmd, "bt stop") == 0) {
        handle_bt_stop(app);
    }

    // GPIO COMMANDS
    else if(strncmp(cmd, "gpio read ", 10) == 0) {
        uint8_t pin = atoi(cmd + 10);
        handle_gpio_read(app, pin);
    }
    else if(strncmp(cmd, "gpio write ", 11) == 0) {
        char* space = strchr(cmd + 11, ' ');
        if(space) {
            uint8_t pin = atoi(cmd + 11);
            bool state = atoi(space + 1);
            handle_gpio_write(app, pin, state);
        }
    }
    else if(strncmp(cmd, "marauder ", 9) == 0) {
        handle_marauder_cmd(app, cmd + 9);
    }

    // APP LAUNCHER COMMANDS
    else if(strncmp(cmd, "launch ", 7) == 0) {
        handle_launch_app(app, cmd + 7);
    }
    else if(strncmp(cmd, "app_control ", 12) == 0) {
        handle_app_control(app, cmd + 12);
    }

    // DEVICE INFO
    else if(strcmp(cmd, "device_info") == 0) {
        char response[RESPONSE_SIZE];
        snprintf(response, sizeof(response),
                "DEVICE_INFO|name:Flipper,version:%s,firmware:Unleashed,target:%d",
                furi_hal_version_get_name_ptr(),
                furi_hal_version_get_hw_target());
        send_response(app, response);
    }

    // UNKNOWN COMMAND
    else {
        char response[RESPONSE_SIZE];
        snprintf(response, sizeof(response), "ERROR|Unknown: %.50s", cmd);
        send_response(app, response);
    }

    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

// ==================== WORKER THREAD ====================

static int32_t worker_thread(void* context) {
    PentestApp* app = context;
    char rx_buffer[RX_BUFFER_SIZE];
    size_t rx_index = 0;

    while(app->running) {
        uint8_t byte;
        if(furi_stream_buffer_receive(app->rx_stream, &byte, 1, 100) > 0) {
            if(byte == '\n' || byte == '\r') {
                if(rx_index > 0) {
                    rx_buffer[rx_index] = '\0';
                    parse_command(app, rx_buffer);
                    rx_index = 0;
                }
            } else if(rx_index < RX_BUFFER_SIZE - 1) {
                rx_buffer[rx_index++] = byte;
            }
        }
    }
    return 0;
}

// ==================== APP LIFECYCLE ====================

static PentestApp* app_alloc() {
    PentestApp* app = malloc(sizeof(PentestApp));
    app->text_buffer = furi_string_alloc();
    furi_string_printf(app->text_buffer,
        "PENTEST COMPANION v2.0\n"
        "Unleashed Firmware\n"
        "ALL MODULES ACTIVE\n"
        "Ready for commands\n\n");

    app->view_dispatcher = view_dispatcher_alloc();
    app->text_box = text_box_alloc();
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
    text_box_set_font(app->text_box, TextBoxFontText);
    view_dispatcher_add_view(app->view_dispatcher, 0, text_box_get_view(app->text_box));

    Gui* gui = furi_record_open(RECORD_GUI);
    view_dispatcher_attach_to_gui(app->view_dispatcher, gui, ViewDispatcherTypeFullscreen);
    view_dispatcher_switch_to_view(app->view_dispatcher, 0);

    app->notifications = furi_record_open(RECORD_NOTIFICATION);

    app->rx_stream = furi_stream_buffer_alloc(RX_BUFFER_SIZE, 1);
    app->serial_handle = furi_hal_serial_control_acquire(UART_CH);
    furi_hal_serial_init(app->serial_handle, 115200);
    furi_hal_serial_async_rx_start(app->serial_handle, usb_rx_callback, app, false);

    app->running = true;
    app->subghz_active = false;
    app->rfid_active = false;
    app->nfc_active = false;
    app->subghz_frequency = 0;

    app->worker_thread = furi_thread_alloc();
    furi_thread_set_name(app->worker_thread, "PentestWorker");
    furi_thread_set_stack_size(app->worker_thread, 2048);
    furi_thread_set_context(app->worker_thread, app);
    furi_thread_set_callback(app->worker_thread, worker_thread);
    furi_thread_start(app->worker_thread);

    notification_message(app->notifications, &sequence_success);
    return app;
}

static void app_free(PentestApp* app) {
    app->running = false;
    furi_thread_join(app->worker_thread);
    furi_thread_free(app->worker_thread);

    // Stop all active modules
    if(app->subghz_active) {
        furi_hal_subghz_idle();
        furi_hal_subghz_sleep();
    }
    if(app->rfid_active) {
        furi_hal_rfid_pins_reset();
    }
    furi_hal_infrared_async_tx_stop();
    furi_hal_infrared_async_rx_stop();
    if(furi_hal_bt_is_active()) {
        furi_hal_bt_stop_advertising();
    }

    furi_hal_serial_async_rx_stop(app->serial_handle);
    furi_hal_serial_deinit(app->serial_handle);
    furi_hal_serial_control_release(app->serial_handle);
    furi_stream_buffer_free(app->rx_stream);

    view_dispatcher_remove_view(app->view_dispatcher, 0);
    text_box_free(app->text_box);
    view_dispatcher_free(app->view_dispatcher);

    furi_record_close(RECORD_NOTIFICATION);
    furi_record_close(RECORD_GUI);

    furi_string_free(app->text_buffer);
    free(app);
}

int32_t pentest_companion_app(void* p) {
    UNUSED(p);
    PentestApp* app = app_alloc();
    view_dispatcher_run(app->view_dispatcher);
    app_free(app);
    return 0;
}
