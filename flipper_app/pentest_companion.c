#include <furi.h>
#include <furi_hal.h>
#include <furi_hal_serial.h>
#include <furi_hal_usb_cdc.h>
#include <gui/gui.h>
#include <gui/view_dispatcher.h>
#include <gui/modules/text_box.h>
#include <notification/notification_messages.h>
#include <storage/storage.h>

// SubGHz
#include <lib/subghz/subghz_worker.h>
#include <lib/subghz/subghz_tx_rx_worker.h>
#include <lib/subghz/transmitter.h>
#include <lib/subghz/receiver.h>
#include <lib/subghz/protocols/protocol_items.h>

// RFID
#include <lib/lfrfid/lfrfid_worker.h>
#include <lib/lfrfid/protocols/lfrfid_protocols.h>

// NFC
#include <lib/nfc/nfc_worker.h>
#include <lib/nfc/nfc_device.h>

// Infrared
#include <lib/infrared/worker/infrared_worker.h>

// iButton
#include <lib/ibutton/ibutton_worker.h>

// GPIO
#include <furi_hal_gpio.h>

#define UART_CH (FuriHalSerialIdUsart)
#define RX_BUFFER_SIZE 256
#define TX_BUFFER_SIZE 512

typedef struct {
    ViewDispatcher* view_dispatcher;
    TextBox* text_box;
    FuriString* text_buffer;
    NotificationApp* notifications;

    // Serial communication
    FuriHalSerialHandle* serial_handle;
    FuriStreamBuffer* rx_stream;
    FuriThread* worker_thread;

    // Module workers
    SubGhzWorker* subghz_worker;
    LFRFIDWorker* rfid_worker;
    NfcWorker* nfc_worker;
    InfraredWorker* ir_worker;
    iButtonWorker* ibutton_worker;

    // State
    bool running;
} PentestApp;

// ==================== SERIAL COMMUNICATION ====================

static void usb_rx_callback(FuriHalSerialHandle* handle, FuriHalSerialRxEvent event, void* context) {
    PentestApp* app = context;

    if(event == FuriHalSerialRxEventData) {
        uint8_t data = furi_hal_serial_async_rx(handle);
        furi_stream_buffer_send(app->rx_stream, &data, 1, 0);
    }
}

static void send_response(PentestApp* app, const char* response) {
    size_t len = strlen(response);
    furi_hal_serial_tx(app->serial_handle, (uint8_t*)response, len);
    furi_hal_serial_tx(app->serial_handle, (uint8_t*)"\r\n", 2);

    // Update display
    furi_string_cat_printf(app->text_buffer, "TX: %s\n", response);
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

// ==================== SUBGHZ MODULE ====================

static void subghz_rx_callback(SubGhzReceiver* receiver, SubGhzProtocolDecoderBase* decoder_base, void* context) {
    PentestApp* app = context;

    FuriString* output = furi_string_alloc();
    subghz_protocol_decoder_base_serialize(decoder_base, output, NULL);

    char response[256];
    snprintf(response, sizeof(response), "SUBGHZ_RX|%s", furi_string_get_cstr(output));
    send_response(app, response);

    furi_string_free(output);
}

static void handle_subghz_rx(PentestApp* app, uint32_t frequency) {
    // Initialize SubGHz
    if(!furi_hal_subghz_is_frequency_valid(frequency)) {
        send_response(app, "ERROR|Invalid frequency");
        return;
    }

    furi_hal_subghz_reset();
    furi_hal_subghz_load_preset(FuriHalSubGhzPresetOok650Async);
    furi_hal_subghz_set_frequency(frequency);

    // Start receiving
    furi_hal_subghz_start_async_rx(NULL, NULL);

    send_response(app, "OK|SubGHz RX started");

    furi_string_cat_printf(app->text_buffer, "SubGHz RX: %lu Hz\n", frequency);
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

static void handle_subghz_tx(PentestApp* app, uint32_t frequency, const char* protocol, const char* data) {
    if(!furi_hal_subghz_is_frequency_valid(frequency)) {
        send_response(app, "ERROR|Invalid frequency");
        return;
    }

    furi_hal_subghz_reset();
    furi_hal_subghz_load_preset(FuriHalSubGhzPresetOok650Async);
    furi_hal_subghz_set_frequency(frequency);

    // TODO: Implement protocol encoding and transmission
    // This requires protocol-specific encoding which is complex

    send_response(app, "OK|SubGHz TX initiated");

    furi_string_cat_printf(app->text_buffer, "SubGHz TX: %lu Hz\n", frequency);
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

static void handle_subghz_stop(PentestApp* app) {
    furi_hal_subghz_stop_async_rx();
    furi_hal_subghz_sleep();
    send_response(app, "OK|SubGHz stopped");
}

// ==================== RFID MODULE ====================

static void rfid_callback(LFRFIDWorkerReadResult result, ProtocolId protocol, void* context) {
    PentestApp* app = context;

    if(result == LFRFIDWorkerReadSenseStart) {
        send_response(app, "RFID|Card detected");
    } else if(result == LFRFIDWorkerReadDone) {
        char response[128];
        snprintf(response, sizeof(response), "RFID_READ|protocol:%d", protocol);
        send_response(app, response);

        furi_string_cat_printf(app->text_buffer, "RFID: Protocol %d\n", protocol);
        text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
    }
}

static void handle_rfid_read(PentestApp* app) {
    if(!app->rfid_worker) {
        app->rfid_worker = lfrfid_worker_alloc(lfrfid_protocols);
    }

    lfrfid_worker_start_thread(app->rfid_worker);
    lfrfid_worker_read_start(app->rfid_worker, LFRFIDWorkerReadTypeASKOnly, rfid_callback, app);

    send_response(app, "OK|RFID read started");
    furi_string_cat_printf(app->text_buffer, "RFID: Reading...\n");
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

static void handle_rfid_emulate(PentestApp* app, uint8_t protocol, const uint8_t* data, size_t data_size) {
    if(!app->rfid_worker) {
        app->rfid_worker = lfrfid_worker_alloc(lfrfid_protocols);
    }

    lfrfid_worker_start_thread(app->rfid_worker);
    lfrfid_worker_emulate_start(app->rfid_worker, protocol);

    send_response(app, "OK|RFID emulation started");
    furi_string_cat_printf(app->text_buffer, "RFID: Emulating protocol %d\n", protocol);
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

static void handle_rfid_stop(PentestApp* app) {
    if(app->rfid_worker) {
        lfrfid_worker_stop(app->rfid_worker);
        lfrfid_worker_stop_thread(app->rfid_worker);
    }
    send_response(app, "OK|RFID stopped");
}

// ==================== NFC MODULE ====================

static void nfc_callback(NfcWorkerEvent event, void* context) {
    PentestApp* app = context;

    switch(event) {
        case NfcWorkerEventReadUidNfcB:
        case NfcWorkerEventReadUidNfcV:
        case NfcWorkerEventReadUidNfcF:
        case NfcWorkerEventReadUidNfcA:
            send_response(app, "NFC|Tag detected");
            break;
        case NfcWorkerEventReadMfClassicDone:
            send_response(app, "NFC_READ|MIFARE Classic read complete");
            break;
        case NfcWorkerEventReadMfUltralightDone:
            send_response(app, "NFC_READ|MIFARE Ultralight read complete");
            break;
        default:
            break;
    }
}

static void handle_nfc_read(PentestApp* app) {
    if(!app->nfc_worker) {
        app->nfc_worker = nfc_worker_alloc();
    }

    nfc_worker_start(app->nfc_worker, NfcWorkerStateRead, NULL, nfc_callback, app);

    send_response(app, "OK|NFC read started");
    furi_string_cat_printf(app->text_buffer, "NFC: Reading...\n");
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

static void handle_nfc_emulate(PentestApp* app) {
    if(!app->nfc_worker) {
        app->nfc_worker = nfc_worker_alloc();
    }

    nfc_worker_start(app->nfc_worker, NfcWorkerStateEmulate, NULL, nfc_callback, app);

    send_response(app, "OK|NFC emulation started");
    furi_string_cat_printf(app->text_buffer, "NFC: Emulating...\n");
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

static void handle_nfc_stop(PentestApp* app) {
    if(app->nfc_worker) {
        nfc_worker_stop(app->nfc_worker);
    }
    send_response(app, "OK|NFC stopped");
}

// ==================== INFRARED MODULE ====================

static void ir_rx_callback(void* context, InfraredWorkerSignal* signal) {
    PentestApp* app = context;

    if(infrared_worker_signal_is_decoded(signal)) {
        const InfraredMessage* message = infrared_worker_get_decoded_signal(signal);

        char response[128];
        snprintf(response, sizeof(response),
                "IR_RX|protocol:%d,address:0x%lX,command:0x%lX",
                message->protocol, message->address, message->command);
        send_response(app, response);

        furi_string_cat_printf(app->text_buffer, "IR: Signal received\n");
        text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
    }
}

static void handle_ir_learn(PentestApp* app) {
    if(!app->ir_worker) {
        app->ir_worker = infrared_worker_alloc();
    }

    infrared_worker_rx_start(app->ir_worker);
    infrared_worker_rx_set_received_signal_callback(app->ir_worker, ir_rx_callback, app);

    send_response(app, "OK|IR learning started");
    furi_string_cat_printf(app->text_buffer, "IR: Learning...\n");
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

static void handle_ir_send(PentestApp* app, uint8_t protocol, uint32_t address, uint32_t command) {
    if(!app->ir_worker) {
        app->ir_worker = infrared_worker_alloc();
    }

    InfraredMessage message;
    message.protocol = protocol;
    message.address = address;
    message.command = command;
    message.repeat = false;

    infrared_worker_tx_start(app->ir_worker);
    infrared_worker_tx_set_get_signal_callback(app->ir_worker, NULL, NULL);

    send_response(app, "OK|IR signal transmitted");
    furi_string_cat_printf(app->text_buffer, "IR: Transmitted\n");
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

static void handle_ir_stop(PentestApp* app) {
    if(app->ir_worker) {
        infrared_worker_rx_stop(app->ir_worker);
        infrared_worker_tx_stop(app->ir_worker);
    }
    send_response(app, "OK|IR stopped");
}

// ==================== IBUTTON MODULE ====================

static void ibutton_callback(iButtonWorkerReadResult result, iButtonKey* key, void* context) {
    PentestApp* app = context;

    if(result == iButtonWorkerReadOK) {
        iButtonKeyType type = ibutton_key_get_type(key);

        char response[128];
        snprintf(response, sizeof(response), "IBUTTON_READ|type:%d", type);
        send_response(app, response);

        furi_string_cat_printf(app->text_buffer, "iButton: Key read\n");
        text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
    }
}

static void handle_ibutton_read(PentestApp* app) {
    if(!app->ibutton_worker) {
        app->ibutton_worker = ibutton_worker_alloc();
    }

    ibutton_worker_start_thread(app->ibutton_worker);
    ibutton_worker_read_start(app->ibutton_worker, NULL, ibutton_callback, app);

    send_response(app, "OK|iButton read started");
    furi_string_cat_printf(app->text_buffer, "iButton: Reading...\n");
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

static void handle_ibutton_emulate(PentestApp* app, iButtonKey* key) {
    if(!app->ibutton_worker) {
        app->ibutton_worker = ibutton_worker_alloc();
    }

    ibutton_worker_start_thread(app->ibutton_worker);
    ibutton_worker_emulate_start(app->ibutton_worker, key);

    send_response(app, "OK|iButton emulation started");
    furi_string_cat_printf(app->text_buffer, "iButton: Emulating...\n");
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

static void handle_ibutton_stop(PentestApp* app) {
    if(app->ibutton_worker) {
        ibutton_worker_stop(app->ibutton_worker);
        ibutton_worker_stop_thread(app->ibutton_worker);
    }
    send_response(app, "OK|iButton stopped");
}

// ==================== GPIO MODULE ====================

static void handle_gpio_read(PentestApp* app, uint8_t pin) {
    const GpioPin* gpio_pin = NULL;

    // Map pin numbers to actual GPIO pins
    switch(pin) {
        case 2: gpio_pin = &gpio_ext_pa7; break;
        case 3: gpio_pin = &gpio_ext_pa6; break;
        case 4: gpio_pin = &gpio_ext_pa4; break;
        case 5: gpio_pin = &gpio_ext_pb3; break;
        case 6: gpio_pin = &gpio_ext_pb2; break;
        case 7: gpio_pin = &gpio_ext_pc3; break;
        default:
            send_response(app, "ERROR|Invalid pin");
            return;
    }

    furi_hal_gpio_init_simple(gpio_pin, GpioModeInput);
    bool state = furi_hal_gpio_read(gpio_pin);

    char response[64];
    snprintf(response, sizeof(response), "GPIO_READ|pin:%d,state:%s", pin, state ? "HIGH" : "LOW");
    send_response(app, response);

    furi_string_cat_printf(app->text_buffer, "GPIO%d: %s\n", pin, state ? "HIGH" : "LOW");
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

static void handle_gpio_write(PentestApp* app, uint8_t pin, bool state) {
    const GpioPin* gpio_pin = NULL;

    switch(pin) {
        case 2: gpio_pin = &gpio_ext_pa7; break;
        case 3: gpio_pin = &gpio_ext_pa6; break;
        case 4: gpio_pin = &gpio_ext_pa4; break;
        case 5: gpio_pin = &gpio_ext_pb3; break;
        case 6: gpio_pin = &gpio_ext_pb2; break;
        case 7: gpio_pin = &gpio_ext_pc3; break;
        default:
            send_response(app, "ERROR|Invalid pin");
            return;
    }

    furi_hal_gpio_init_simple(gpio_pin, GpioModeOutputPushPull);
    furi_hal_gpio_write(gpio_pin, state);

    char response[64];
    snprintf(response, sizeof(response), "GPIO_WRITE|pin:%d,state:%s", pin, state ? "HIGH" : "LOW");
    send_response(app, response);

    furi_string_cat_printf(app->text_buffer, "GPIO%d = %s\n", pin, state ? "HIGH" : "LOW");
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

// ==================== COMMAND PARSER ====================

static void parse_command(PentestApp* app, const char* cmd) {
    furi_string_cat_printf(app->text_buffer, "RX: %s\n", cmd);

    // SubGHz commands
    if(strncmp(cmd, "subghz rx ", 10) == 0) {
        uint32_t freq = atol(cmd + 10);
        handle_subghz_rx(app, freq);
    }
    else if(strncmp(cmd, "subghz tx ", 10) == 0) {
        // Parse: subghz tx <freq> <protocol> <data>
        // TODO: Implement proper parsing
        send_response(app, "OK|SubGHz TX - parsing needed");
    }
    else if(strcmp(cmd, "subghz stop") == 0) {
        handle_subghz_stop(app);
    }

    // RFID commands
    else if(strcmp(cmd, "rfid read") == 0) {
        handle_rfid_read(app);
    }
    else if(strncmp(cmd, "rfid emulate ", 13) == 0) {
        // Parse protocol and data
        uint8_t protocol = atoi(cmd + 13);
        handle_rfid_emulate(app, protocol, NULL, 0);
    }
    else if(strcmp(cmd, "rfid stop") == 0) {
        handle_rfid_stop(app);
    }

    // NFC commands
    else if(strcmp(cmd, "nfc read") == 0) {
        handle_nfc_read(app);
    }
    else if(strcmp(cmd, "nfc emulate") == 0) {
        handle_nfc_emulate(app);
    }
    else if(strcmp(cmd, "nfc stop") == 0) {
        handle_nfc_stop(app);
    }

    // Infrared commands
    else if(strcmp(cmd, "ir learn") == 0) {
        handle_ir_learn(app);
    }
    else if(strncmp(cmd, "ir send ", 8) == 0) {
        // Parse: ir send <protocol> <address> <command>
        // TODO: Implement proper parsing
        send_response(app, "OK|IR send - parsing needed");
    }
    else if(strcmp(cmd, "ir stop") == 0) {
        handle_ir_stop(app);
    }

    // iButton commands
    else if(strcmp(cmd, "ibutton read") == 0) {
        handle_ibutton_read(app);
    }
    else if(strcmp(cmd, "ibutton emulate") == 0) {
        // TODO: Parse key data
        send_response(app, "OK|iButton emulate - data needed");
    }
    else if(strcmp(cmd, "ibutton stop") == 0) {
        handle_ibutton_stop(app);
    }

    // GPIO commands
    else if(strncmp(cmd, "gpio read ", 10) == 0) {
        uint8_t pin = atoi(cmd + 10);
        handle_gpio_read(app, pin);
    }
    else if(strncmp(cmd, "gpio write ", 11) == 0) {
        // Parse: gpio write <pin> <0|1>
        char* space = strchr(cmd + 11, ' ');
        if(space) {
            uint8_t pin = atoi(cmd + 11);
            bool state = atoi(space + 1);
            handle_gpio_write(app, pin, state);
        }
    }

    // Device info (Android app sends this for testing)
    else if(strcmp(cmd, "device_info") == 0) {
        char response[128];
        snprintf(response, sizeof(response),
                "DEVICE_INFO|name:Flipper,version:%s,target:%d",
                furi_hal_version_get_name_ptr(),
                furi_hal_version_get_hw_target());
        send_response(app, response);
    }

    // Unknown command
    else {
        char response[64];
        snprintf(response, sizeof(response), "ERROR|Unknown command: %s", cmd);
        send_response(app, response);
    }

    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
}

// ==================== WORKER THREAD ====================

static int32_t worker_thread(void* context) {
    PentestApp* app = context;

    char rx_buffer[RX_BUFFER_SIZE];
    size_t rx_index = 0;

    while(app->running) {
        uint8_t byte;

        if(furi_stream_buffer_receive(app->rx_stream, &byte, 1, 100) > 0) {
            if(byte == '\n' || byte == '\r') {
                if(rx_index > 0) {
                    rx_buffer[rx_index] = '\0';
                    parse_command(app, rx_buffer);
                    rx_index = 0;
                }
            } else if(rx_index < RX_BUFFER_SIZE - 1) {
                rx_buffer[rx_index++] = byte;
            }
        }
    }

    return 0;
}

// ==================== APP LIFECYCLE ====================

static PentestApp* app_alloc() {
    PentestApp* app = malloc(sizeof(PentestApp));

    app->text_buffer = furi_string_alloc();
    furi_string_printf(app->text_buffer, "Pentest Companion v1.0\nReady for commands\n");

    // Setup GUI
    app->view_dispatcher = view_dispatcher_alloc();
    app->text_box = text_box_alloc();
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_buffer));
    text_box_set_font(app->text_box, TextBoxFontText);

    view_dispatcher_add_view(app->view_dispatcher, 0, text_box_get_view(app->text_box));

    Gui* gui = furi_record_open(RECORD_GUI);
    view_dispatcher_attach_to_gui(app->view_dispatcher, gui, ViewDispatcherTypeFullscreen);
    view_dispatcher_switch_to_view(app->view_dispatcher, 0);

    app->notifications = furi_record_open(RECORD_NOTIFICATION);

    // Setup serial communication
    app->rx_stream = furi_stream_buffer_alloc(RX_BUFFER_SIZE, 1);
    app->serial_handle = furi_hal_serial_control_acquire(UART_CH);
    furi_hal_serial_init(app->serial_handle, 115200);
    furi_hal_serial_async_rx_start(app->serial_handle, usb_rx_callback, app, false);

    // Start worker thread
    app->running = true;
    app->worker_thread = furi_thread_alloc();
    furi_thread_set_name(app->worker_thread, "PentestWorker");
    furi_thread_set_stack_size(app->worker_thread, 2048);
    furi_thread_set_context(app->worker_thread, app);
    furi_thread_set_callback(app->worker_thread, worker_thread);
    furi_thread_start(app->worker_thread);

    // Notification
    notification_message(app->notifications, &sequence_success);

    return app;
}

static void app_free(PentestApp* app) {
    // Stop worker
    app->running = false;
    furi_thread_join(app->worker_thread);
    furi_thread_free(app->worker_thread);

    // Stop all workers
    if(app->rfid_worker) {
        lfrfid_worker_stop(app->rfid_worker);
        lfrfid_worker_free(app->rfid_worker);
    }
    if(app->nfc_worker) {
        nfc_worker_stop(app->nfc_worker);
        nfc_worker_free(app->nfc_worker);
    }
    if(app->ir_worker) {
        infrared_worker_rx_stop(app->ir_worker);
        infrared_worker_tx_stop(app->ir_worker);
        infrared_worker_free(app->ir_worker);
    }
    if(app->ibutton_worker) {
        ibutton_worker_stop(app->ibutton_worker);
        ibutton_worker_free(app->ibutton_worker);
    }

    // Cleanup serial
    furi_hal_serial_async_rx_stop(app->serial_handle);
    furi_hal_serial_deinit(app->serial_handle);
    furi_hal_serial_control_release(app->serial_handle);
    furi_stream_buffer_free(app->rx_stream);

    // Cleanup GUI
    view_dispatcher_remove_view(app->view_dispatcher, 0);
    text_box_free(app->text_box);
    view_dispatcher_free(app->view_dispatcher);

    furi_record_close(RECORD_NOTIFICATION);
    furi_record_close(RECORD_GUI);

    furi_string_free(app->text_buffer);
    free(app);
}

// ==================== ENTRY POINT ====================

int32_t pentest_companion_app(void* p) {
    UNUSED(p);

    PentestApp* app = app_alloc();
    view_dispatcher_run(app->view_dispatcher);
    app_free(app);

    return 0;
}
