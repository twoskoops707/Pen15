package com.pentest.dashboard

import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.net.Uri
import android.os.Bundle
import android.provider.Settings
import android.view.View
import android.widget.ImageView
import android.widget.ProgressBar
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import com.google.android.material.button.MaterialButton
import com.google.android.material.switchmaterial.SwitchMaterial
import java.io.BufferedReader
import java.io.File
import java.io.InputStreamReader

class SettingsActivity : AppCompatActivity() {

    private lateinit var prefs: SharedPreferences
    private lateinit var switchAutoConnect: SwitchMaterial
    private lateinit var switchVerboseLogging: SwitchMaterial
    private lateinit var switchKeepScreenOn: SwitchMaterial
    
    // Progress dialog elements
    private lateinit var progressContainer: View
    private lateinit var progressTitle: TextView
    private lateinit var progressOutput: TextView
    private lateinit var progressBar: ProgressBar
    private lateinit var btnCloseProgress: MaterialButton
    private lateinit var termuxStatusDot: View
    private lateinit var termuxStatusText: TextView

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_settings)

        prefs = getSharedPreferences("pentest_settings", Context.MODE_PRIVATE)

        initializeViews()
        loadSettings()
        setupClickListeners()
        checkTermuxStatus()
    }

    private fun initializeViews() {
        switchAutoConnect = findViewById(R.id.switchAutoConnect)
        switchVerboseLogging = findViewById(R.id.switchVerboseLogging)
        switchKeepScreenOn = findViewById(R.id.switchKeepScreenOn)
        
        progressContainer = findViewById(R.id.progressContainer)
        progressTitle = findViewById(R.id.progressTitle)
        progressOutput = findViewById(R.id.progressOutput)
        progressBar = findViewById(R.id.progressBar)
        btnCloseProgress = findViewById(R.id.btnCloseProgress)
        termuxStatusDot = findViewById(R.id.termuxStatusDot)
        termuxStatusText = findViewById(R.id.termuxStatusText)
    }

    private fun loadSettings() {
        switchAutoConnect.isChecked = prefs.getBoolean("auto_connect", false)
        switchVerboseLogging.isChecked = prefs.getBoolean("verbose_logging", false)
        switchKeepScreenOn.isChecked = prefs.getBoolean("keep_screen_on", false)
    }

    private fun setupClickListeners() {
        findViewById<ImageView>(R.id.btnBack).setOnClickListener { finish() }

        // Auto-connect toggle
        switchAutoConnect.setOnCheckedChangeListener { _, isChecked ->
            prefs.edit().putBoolean("auto_connect", isChecked).apply()
            Toast.makeText(this,
                if (isChecked) "Auto-connect enabled" else "Auto-connect disabled",
                Toast.LENGTH_SHORT).show()
        }

        // Verbose logging toggle
        switchVerboseLogging.setOnCheckedChangeListener { _, isChecked ->
            prefs.edit().putBoolean("verbose_logging", isChecked).apply()
        }

        // Keep screen on toggle
        switchKeepScreenOn.setOnCheckedChangeListener { _, isChecked ->
            prefs.edit().putBoolean("keep_screen_on", isChecked).apply()
        }

        // Bluetooth Settings button
        findViewById<MaterialButton>(R.id.btnBluetoothSettings).setOnClickListener {
            try {
                startActivity(Intent(Settings.ACTION_BLUETOOTH_SETTINGS))
            } catch (e: Exception) {
                Toast.makeText(this, "Could not open Bluetooth settings", Toast.LENGTH_SHORT).show()
            }
        }

        // Install Termux button
        findViewById<MaterialButton>(R.id.btnInstallTermux).setOnClickListener {
            try {
                val intent = Intent(Intent.ACTION_VIEW, Uri.parse("https://f-droid.org/packages/com.termux/"))
                startActivity(intent)
            } catch (e: Exception) {
                Toast.makeText(this, "Could not open F-Droid", Toast.LENGTH_SHORT).show()
            }
        }

        // Check Tools button - REAL implementation
        findViewById<MaterialButton>(R.id.btnCheckTools).setOnClickListener {
            showProgressDialog("[SCANNING TOOLS]")
            executeTermuxCommand(TermuxIntegration.Setup.checkTools())
        }

        // Install Tools button - REAL implementation
        findViewById<MaterialButton>(R.id.btnInstallTools).setOnClickListener {
            showProgressDialog("[INSTALLING TOOLS]")
            appendProgress("WARNING: This will take 10-30 minutes!")
            appendProgress("Installing: aircrack, hashcat, nmap, metasploit...")
            appendProgress("")
            executeTermuxCommand(TermuxIntegration.Setup.installTools())
        }

        // Clear cache button
        findViewById<MaterialButton>(R.id.btnClearCache).setOnClickListener {
            try {
                cacheDir.deleteRecursively()
                Toast.makeText(this, "Cache cleared", Toast.LENGTH_SHORT).show()
            } catch (e: Exception) {
                Toast.makeText(this, "Could not clear cache", Toast.LENGTH_SHORT).show()
            }
        }

        // About button
        findViewById<MaterialButton>(R.id.btnAbout).setOnClickListener {
            Toast.makeText(this, 
                "Flipper Zero Dashboard v1.0\n" +
                "Real pyflipper integration\n" +
                "No fake code - actual API calls\n" +
                "For authorized security testing only", 
                Toast.LENGTH_LONG).show()
        }

        // Close progress dialog
        btnCloseProgress.setOnClickListener {
            hideProgressDialog()
        }
    }

    private fun checkTermuxStatus() {
        Thread {
            try {
                // Check if Termux is installed
                val termuxInstalled = packageManager.getPackageInfo("com.termux", 0) != null
                
                // Check if python3 exists
                val pythonCheck = executeCommand("command -v python3")
                val pythonInstalled = pythonCheck.contains("/python3")
                
                runOnUiThread {
                    when {
                        !termuxInstalled -> {
                            termuxStatusDot.backgroundTintList = android.content.res.ColorStateList.valueOf(
                                getColor(R.color.status_disconnected)
                            )
                            termuxStatusText.text = "tools_status: termux_not_installed"
                        }
                        !pythonInstalled -> {
                            termuxStatusDot.backgroundTintList = android.content.res.ColorStateList.valueOf(
                                getColor(R.color.status_scanning)
                            )
                            termuxStatusText.text = "tools_status: python_missing"
                        }
                        else -> {
                            termuxStatusDot.backgroundTintList = android.content.res.ColorStateList.valueOf(
                                getColor(R.color.status_connected)
                            )
                            termuxStatusText.text = "tools_status: ready"
                        }
                    }
                }
            } catch (e: Exception) {
                runOnUiThread {
                    termuxStatusDot.backgroundTintList = android.content.res.ColorStateList.valueOf(
                        getColor(R.color.status_disconnected)
                    )
                    termuxStatusText.text = "tools_status: error"
                }
            }
        }.start()
    }

    private fun showProgressDialog(title: String) {
        progressTitle.text = title
        progressOutput.text = "$ initializing...\n"
        progressBar.isIndeterminate = true
        btnCloseProgress.isEnabled = false
        btnCloseProgress.backgroundTintList = android.content.res.ColorStateList.valueOf(
            getColor(R.color.text_dim)
        )
        progressContainer.visibility = View.VISIBLE
    }

    private fun hideProgressDialog() {
        progressContainer.visibility = View.GONE
    }

    private fun appendProgress(text: String) {
        runOnUiThread {
            val current = progressOutput.text.toString()
            progressOutput.text = "$current$text\n"
            
            // Auto-scroll to bottom
            progressOutput.post {
                val scrollView = progressOutput.parent as? android.widget.ScrollView
                scrollView?.fullScroll(View.FOCUS_DOWN)
            }
        }
    }

    private fun completeProgress() {
        runOnUiThread {
            progressBar.isIndeterminate = false
            btnCloseProgress.isEnabled = true
            btnCloseProgress.backgroundTintList = android.content.res.ColorStateList.valueOf(
                getColor(R.color.neon_cyan)
            )
            appendProgress("")
            appendProgress("[COMPLETE]")
        }
    }

    private fun executeTermuxCommand(command: String) {
        Thread {
            try {
                appendProgress("$ executing command...")
                appendProgress("")
                
                val termux = TermuxIntegration(this)
                val outputFile = File(cacheDir, "termux_output_${System.currentTimeMillis()}.txt")
                
                // Write command to file for Termux to execute
                val scriptFile = File(cacheDir, "exec_script.sh")
                scriptFile.writeText("#!/data/data/com.termux/files/usr/bin/bash\n$command\n")
                scriptFile.setExecutable(true)
                
                // Execute via Termux
                val success = termux.runCommand(
                    "bash ${scriptFile.absolutePath} > ${outputFile.absolutePath} 2>&1",
                    background = true
                )
                
                if (success) {
                    appendProgress("[OK] Command sent to Termux")
                    appendProgress("")
                    
                    // Poll for output with timeout
                    var attempts = 0
                    val maxAttempts = 60 // 60 seconds timeout
                    
                    while (attempts < maxAttempts) {
                        Thread.sleep(1000)
                        attempts++
                        
                        if (outputFile.exists() && outputFile.length() > 0) {
                            val output = outputFile.readText()
                            
                            runOnUiThread {
                                progressOutput.text = "$ executing command...\n\n$output"
                            }
                            
                            // Check if command finished (look for common completion markers)
                            if (output.contains("done") || 
                                output.contains("complete") || 
                                output.contains("installed") ||
                                output.contains("error") ||
                                output.length > 5000) { // Large output means it's done
                                break
                            }
                        }
                        
                        if (attempts % 5 == 0) {
                            appendProgress("... still running (${attempts}s)")
                        }
                    }
                    
                    if (attempts >= maxAttempts) {
                        appendProgress("")
                        appendProgress("[WARN] Timeout - check Termux manually")
                    }
                } else {
                    appendProgress("[ERR] Failed to execute in Termux")
                    appendProgress("Make sure Termux is installed")
                }
                
                completeProgress()
                checkTermuxStatus() // Refresh status
                
            } catch (e: Exception) {
                appendProgress("")
                appendProgress("ERROR: ${e.message}")
                completeProgress()
            }
        }.start()
    }

    private fun executeCommand(command: String): String {
        return try {
            val process = Runtime.getRuntime().exec(arrayOf("/data/data/com.termux/files/usr/bin/bash", "-c", command))
            val reader = BufferedReader(InputStreamReader(process.inputStream))
            val output = StringBuilder()
            var line: String?
            while (reader.readLine().also { line = it } != null) {
                output.append(line).append("\n")
            }
            process.waitFor()
            reader.close()
            output.toString()
        } catch (e: Exception) {
            ""
        }
    }
}
