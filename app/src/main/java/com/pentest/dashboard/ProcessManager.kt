package com.pentest.dashboard

import android.content.Context
import java.io.File
import java.util.UUID

/**
 * Manages running Termux processes
 * Tracks PIDs and allows killing scripts
 */
object ProcessManager {
    private var currentProcessId: String? = null
    private var currentScriptFile: File? = null

    /**
     * Start a new process, killing any existing one first
     */
    fun startProcess(context: Context, script: String): String {
        // Kill any existing process
        stopCurrentProcess(context)

        // Generate unique process ID
        val processId = UUID.randomUUID().toString().substring(0, 8)
        currentProcessId = processId

        // Create script file with PID tracking
        val scriptDir = File(context.getExternalFilesDir(null), "scripts")
        scriptDir.mkdirs()

        val scriptFile = File(scriptDir, "script_$processId.sh")
        currentScriptFile = scriptFile

        // Add PID tracking and output logging to script
        val wrappedScript = """
            #!/data/data/com.termux/files/usr/bin/bash

            # Store PID for tracking
            PID_FILE="${context.getExternalFilesDir(null)}/scripts/pid_$processId.txt"
            echo ${'$'}${'$'} > "${'$'}PID_FILE"

            # Output file for live results
            OUTPUT_FILE="${context.getExternalFilesDir(null)}/scripts/output_$processId.txt"

            # Cleanup on exit
            cleanup() {
                rm -f "${'$'}PID_FILE"
            }
            trap cleanup EXIT

            # Run the actual script with output logging
            (
                $script
            ) 2>&1 | tee "${'$'}OUTPUT_FILE"
        """.trimIndent()

        scriptFile.writeText(wrappedScript)
        scriptFile.setExecutable(true)

        return processId
    }

    /**
     * Stop the currently running process
     */
    fun stopCurrentProcess(context: Context) {
        currentProcessId?.let { processId ->
            val termux = TermuxIntegration(context)

            // Read PID from file
            val pidFile = File(context.getExternalFilesDir(null), "scripts/pid_$processId.txt")
            if (pidFile.exists()) {
                val pid = pidFile.readText().trim()
                if (pid.isNotEmpty()) {
                    // Kill the process and all children
                    val killScript = """
                        pkill -P $pid
                        kill $pid 2>/dev/null
                        echo "Process $pid stopped"
                    """.trimIndent()
                    termux.runCommand(killScript, background = false)
                }
                pidFile.delete()
            }

            // Clean up script file
            currentScriptFile?.delete()
        }

        currentProcessId = null
        currentScriptFile = null
    }

    /**
     * Get output file path for current process
     */
    fun getOutputFile(context: Context): File? {
        return currentProcessId?.let {
            File(context.getExternalFilesDir(null), "scripts/output_$it.txt")
        }
    }

    /**
     * Check if a process is currently running
     */
    fun isProcessRunning(context: Context): Boolean {
        currentProcessId?.let { processId ->
            val pidFile = File(context.getExternalFilesDir(null), "scripts/pid_$processId.txt")
            return pidFile.exists()
        }
        return false
    }

    /**
     * Get current process ID
     */
    fun getCurrentProcessId(): String? = currentProcessId
}
