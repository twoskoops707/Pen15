package com.pentest.dashboard

import android.app.PendingIntent
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.hardware.usb.UsbDevice
import android.hardware.usb.UsbDeviceConnection
import android.hardware.usb.UsbManager
import android.os.Handler
import android.os.Looper
import android.util.Log
import android.widget.Toast
import com.hoho.android.usbserial.driver.UsbSerialDriver
import com.hoho.android.usbserial.driver.UsbSerialPort
import com.hoho.android.usbserial.driver.UsbSerialProber
import java.io.IOException

/**
 * Flipper Zero USB Serial Communication Manager
 *
 * Handles USB serial communication with Flipper Zero via USB-C cable.
 * More reliable and faster than Bluetooth.
 *
 * Flipper Zero USB Details:
 * - Vendor ID: 0x0483 (STMicroelectronics)
 * - Product ID: 0x5740 (Virtual COM Port)
 * - Baud Rate: 115200
 * - Data Bits: 8
 * - Stop Bits: 1
 * - Parity: None
 */
class FlipperUSBManager(private val context: Context) {

    companion object {
        private const val TAG = "FlipperUSB"
        private const val ACTION_USB_PERMISSION = "com.pentest.dashboard.USB_PERMISSION"

        // Flipper Zero USB identifiers
        private const val FLIPPER_VENDOR_ID = 0x0483
        private const val FLIPPER_PRODUCT_ID = 0x5740

        // Serial settings
        private const val BAUD_RATE = 115200
        private const val DATA_BITS = 8
        private const val STOP_BITS = UsbSerialPort.STOPBITS_1
        private const val PARITY = UsbSerialPort.PARITY_NONE
    }

    private val usbManager: UsbManager = context.getSystemService(Context.USB_SERVICE) as UsbManager
    private val handler = Handler(Looper.getMainLooper())

    private var serialPort: UsbSerialPort? = null
    private var usbConnection: UsbDeviceConnection? = null
    private var readingThread: Thread? = null
    @Volatile private var shouldContinueReading = false

    private var connectionCallback: ((Boolean, String) -> Unit)? = null
    private var dataReceivedCallback: ((String) -> Unit)? = null

    private val usbPermissionReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context, intent: Intent) {
            if (ACTION_USB_PERMISSION == intent.action) {
                synchronized(this) {
                    val device: UsbDevice? = if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.TIRAMISU) {
                        intent.getParcelableExtra(UsbManager.EXTRA_DEVICE, UsbDevice::class.java)
                    } else {
                        @Suppress("DEPRECATION")
                        intent.getParcelableExtra(UsbManager.EXTRA_DEVICE)
                    }

                    if (intent.getBooleanExtra(UsbManager.EXTRA_PERMISSION_GRANTED, false)) {
                        device?.let {
                            try {
                                connectToDevice(it)
                            } catch (e: Exception) {
                                Log.e(TAG, "Error connecting to device", e)
                                handler.post {
                                    connectionCallback?.invoke(false, "Connection error: ${e.message}")
                                }
                            }
                        }
                    } else {
                        Log.d(TAG, "USB permission denied")
                        handler.post {
                            connectionCallback?.invoke(false, "USB permission denied")
                        }
                    }
                }
            }
        }
    }

    init {
        val filter = IntentFilter(ACTION_USB_PERMISSION)
        context.registerReceiver(usbPermissionReceiver, filter)
    }

    /**
     * Detect and connect to Flipper Zero via USB
     */
    fun connect(callback: (Boolean, String) -> Unit) {
        connectionCallback = callback

        Log.d(TAG, "=== CONNECT CALLED ===")

        try {
            val flipperDevice = findFlipperDevice()
            if (flipperDevice == null) {
                Log.e(TAG, "findFlipperDevice returned null")
                handler.post {
                    callback(false, "No Flipper found. Check USB cable & permissions.")
                }
                return
            }

            Log.d(TAG, "Flipper device found! Checking permission...")

            // Check if we have permission
            if (usbManager.hasPermission(flipperDevice)) {
                Log.d(TAG, "Permission already granted, connecting...")
                connectToDevice(flipperDevice)
            } else {
                Log.d(TAG, "Requesting USB permission...")
                // Request permission
                val permissionIntent = PendingIntent.getBroadcast(
                    context,
                    0,
                    Intent(ACTION_USB_PERMISSION),
                    PendingIntent.FLAG_IMMUTABLE
                )
                usbManager.requestPermission(flipperDevice, permissionIntent)

                // Give user feedback
                handler.post {
                    Toast.makeText(context, "Grant USB permission when asked", Toast.LENGTH_LONG).show()
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Exception in connect()", e)
            handler.post {
                callback(false, "Error: ${e.message}")
            }
        }
    }

    /**
     * Find Flipper Zero USB device
     */
    private fun findFlipperDevice(): UsbDevice? {
        try {
            val deviceList = usbManager.deviceList

            // Log ALL USB devices for debugging
            Log.d(TAG, "=== USB DEVICE SCAN ===")
            Log.d(TAG, "Total USB devices found: ${deviceList.size}")

            // Show user feedback
            handler.post {
                Toast.makeText(context, "Scanning ${deviceList.size} USB devices...", Toast.LENGTH_SHORT).show()
            }

            if (deviceList.isEmpty()) {
                Log.w(TAG, "NO USB DEVICES FOUND!")
                Log.w(TAG, "Make sure:")
                Log.w(TAG, "1. Flipper is connected via USB-C cable")
                Log.w(TAG, "2. Cable supports data (not just charging)")
                Log.w(TAG, "3. Flipper screen shows 'USB Connected'")

                handler.post {
                    Toast.makeText(context, "No USB devices found!\n\nCheck:\n• USB cable connected?\n• Data cable (not charge-only)?", Toast.LENGTH_LONG).show()
                }
                return null
            }

            for ((_, device) in deviceList) {
                val vid = String.format("0x%04X", device.vendorId)
                val pid = String.format("0x%04X", device.productId)
                val name = device.productName ?: "Unknown"
                val mfg = device.manufacturerName ?: "Unknown"

                Log.d(TAG, "Device: $name")
                Log.d(TAG, "  Manufacturer: $mfg")
                Log.d(TAG, "  VID: $vid (need: 0x0483)")
                Log.d(TAG, "  PID: $pid (need: 0x5740)")
                Log.d(TAG, "  DeviceClass: ${device.deviceClass}")
                Log.d(TAG, "  InterfaceCount: ${device.interfaceCount}")
                Log.d(TAG, "")

                if (device.vendorId == FLIPPER_VENDOR_ID && device.productId == FLIPPER_PRODUCT_ID) {
                    Log.d(TAG, "✓ FLIPPER ZERO FOUND!")
                    handler.post {
                        Toast.makeText(context, "✓ Found: $name", Toast.LENGTH_SHORT).show()
                    }
                    return device
                }
            }

            Log.w(TAG, "✗ Flipper Zero NOT found in USB devices")
            Log.w(TAG, "Expected: VID=0x0483, PID=0x5740")

            // Show what we DID find
            val foundDevices = deviceList.values.joinToString("\n") {
                "${it.productName ?: "Unknown"} (${String.format("0x%04X", it.vendorId)}:${String.format("0x%04X", it.productId)})"
            }

            handler.post {
                Toast.makeText(context,
                    "Flipper not found!\n\nFound these devices:\n$foundDevices\n\nExpected: 0x0483:0x5740",
                    Toast.LENGTH_LONG).show()
            }

            return null
        } catch (e: Exception) {
            Log.e(TAG, "Exception in findFlipperDevice", e)
            handler.post {
                Toast.makeText(context, "Error scanning USB: ${e.message}", Toast.LENGTH_LONG).show()
            }
            return null
        }
    }

    /**
     * Connect to the USB device and open serial port
     */
    private fun connectToDevice(device: UsbDevice) {
        try {
            // Ensure we're searching for the correct device
            Log.d(TAG, "Attempting to connect to device: ${device.productName}")

            // Find USB serial driver
            val drivers = UsbSerialProber.getDefaultProber().findAllDrivers(usbManager)

            if (drivers.isEmpty()) {
                Log.e(TAG, "No USB serial driver found - trying custom prober...")

                // Try building a custom prober for Flipper Zero
                val customTableProber = UsbSerialProber.getDefaultProber()
                val customDrivers = customTableProber.findAllDrivers(usbManager)

                if (customDrivers.isEmpty()) {
                    Log.e(TAG, "Custom prober also failed")
                    handler.post {
                        Toast.makeText(context, "USB driver not found.\n\nTry:\n1. Disconnect and reconnect cable\n2. Restart Flipper Zero\n3. Use a different USB cable", Toast.LENGTH_LONG).show()
                        connectionCallback?.invoke(false, "USB driver not found - reconnect cable")
                    }
                    return
                }
            }

            // Find the correct driver for our device
            val driver = drivers.find { it.device.vendorId == device.vendorId && it.device.productId == device.productId }
                ?: drivers.firstOrNull()

            if (driver == null) {
                Log.e(TAG, "No compatible driver found for device")
                handler.post {
                    connectionCallback?.invoke(false, "No compatible USB driver")
                }
                return
            }

            Log.d(TAG, "Using driver: ${driver.javaClass.simpleName}")

            // Open device connection with retries
            var retryCount = 0
            val maxRetries = 3
            var success = false

            while (retryCount < maxRetries && !success) {
                try {
                    usbConnection = usbManager.openDevice(driver.device)
                    if (usbConnection != null) {
                        success = true
                        Log.d(TAG, "USB device opened successfully on attempt ${retryCount + 1}")
                    } else {
                        retryCount++
                        Log.w(TAG, "Failed to open USB device, attempt $retryCount/$maxRetries")
                        Thread.sleep(500)
                    }
                } catch (e: Exception) {
                    retryCount++
                    Log.e(TAG, "Exception opening device, attempt $retryCount/$maxRetries", e)
                    if (retryCount < maxRetries) {
                        Thread.sleep(500)
                    }
                }
            }

            if (usbConnection == null) {
                Log.e(TAG, "Failed to open USB connection after $maxRetries attempts")
                handler.post {
                    Toast.makeText(context, "Failed to open USB connection.\n\nTry:\n• Disconnect and reconnect\n• Grant USB permissions again", Toast.LENGTH_LONG).show()
                    connectionCallback?.invoke(false, "Failed to open USB - try reconnecting")
                }
                return
            }

            // Open serial port
            if (driver.ports.isEmpty()) {
                Log.e(TAG, "No serial ports available on driver")
                handler.post {
                    connectionCallback?.invoke(false, "No serial ports found")
                }
                return
            }

            serialPort = driver.ports[0]

            // Configure serial port with proper error handling
            try {
                serialPort?.open(usbConnection)
                serialPort?.setParameters(BAUD_RATE, DATA_BITS, STOP_BITS, PARITY)
                serialPort?.dtr = true  // Enable DTR (Data Terminal Ready)
                serialPort?.rts = true  // Enable RTS (Request To Send)

                Log.d(TAG, "✓ USB serial port configured: $BAUD_RATE baud, 8N1, DTR/RTS enabled")
            } catch (e: IOException) {
                Log.e(TAG, "Error configuring serial port", e)
                serialPort?.close()
                usbConnection?.close()
                handler.post {
                    connectionCallback?.invoke(false, "Error configuring port: ${e.message}")
                }
                return
            }

            // Verify connection by sending a test command
            try {
                val testCmd = "device_info\r\n"
                serialPort?.write(testCmd.toByteArray(), 1000)
                Log.d(TAG, "Test command sent successfully")
            } catch (e: IOException) {
                Log.w(TAG, "Warning: Test command failed, but connection may still work", e)
            }

            Log.d(TAG, "✓ USB serial port opened and ready")
            handler.post {
                Toast.makeText(context, "✓ Flipper Zero connected via USB!", Toast.LENGTH_SHORT).show()
                connectionCallback?.invoke(true, "Connected via USB-C")
            }

            // Start reading data
            startReading()

        } catch (e: IOException) {
            Log.e(TAG, "IOException in connectToDevice", e)
            cleanup()
            handler.post {
                Toast.makeText(context, "Connection failed: ${e.message}", Toast.LENGTH_LONG).show()
                connectionCallback?.invoke(false, "Error: ${e.message}")
            }
        } catch (e: Exception) {
            Log.e(TAG, "Unexpected exception in connectToDevice", e)
            cleanup()
            handler.post {
                Toast.makeText(context, "Unexpected error: ${e.message}", Toast.LENGTH_LONG).show()
                connectionCallback?.invoke(false, "Unexpected error: ${e.message}")
            }
        }
    }

    private fun cleanup() {
        try {
            serialPort?.close()
            usbConnection?.close()
        } catch (e: Exception) {
            Log.w(TAG, "Error during cleanup", e)
        }
        serialPort = null
        usbConnection = null
    }

    /**
     * Start reading data from serial port
     */
    private fun startReading() {
        shouldContinueReading = true
        readingThread = Thread {
            val buffer = ByteArray(1024)
            while (shouldContinueReading && serialPort != null) {
                try {
                    val numBytes = serialPort?.read(buffer, 1000) ?: 0
                    if (numBytes > 0) {
                        val data = String(buffer, 0, numBytes)
                        Log.d(TAG, "Received: $data")
                        handler.post {
                            dataReceivedCallback?.invoke(data)
                        }
                    }
                } catch (e: IOException) {
                    Log.e(TAG, "Error reading from serial port", e)
                    break
                }
            }
            Log.d(TAG, "Reading thread stopped")
        }.apply {
            name = "FlipperUSB-Reader"
            start()
        }
    }

    /**
     * Send command to Flipper Zero via USB
     */
    fun sendCommand(command: String): Boolean {
        try {
            // Ensure command ends with \r\n for proper parsing
            val cmd = if (!command.endsWith("\r\n") && !command.endsWith("\n")) {
                "$command\r\n"
            } else {
                command
            }
            val data = cmd.toByteArray()
            serialPort?.write(data, 1000)
            Log.d(TAG, "Sent command: $cmd")
            return true
        } catch (e: IOException) {
            Log.e(TAG, "Error sending command", e)
            return false
        }
    }

    /**
     * Set callback for receiving data from Flipper
     */
    fun setDataReceivedCallback(callback: (String) -> Unit) {
        dataReceivedCallback = callback
    }

    /**
     * Disconnect from Flipper Zero
     */
    fun disconnect() {
        // Stop reading thread first
        shouldContinueReading = false
        try {
            readingThread?.join(2000) // Wait max 2 seconds for thread to finish
        } catch (e: InterruptedException) {
            Thread.currentThread().interrupt()
            Log.w(TAG, "Interrupted while waiting for reading thread")
        }

        // Close connections
        try {
            serialPort?.close()
            usbConnection?.close()
            serialPort = null
            usbConnection = null
            readingThread = null
            Log.d(TAG, "Disconnected from Flipper Zero")
        } catch (e: IOException) {
            Log.e(TAG, "Error disconnecting", e)
        }
    }

    /**
     * Check if Flipper Zero is connected via USB
     */
    fun isConnected(): Boolean {
        return serialPort != null
    }

    /**
     * Clean up resources
     */
    fun cleanup() {
        disconnect()
        try {
            context.unregisterReceiver(usbPermissionReceiver)
        } catch (e: Exception) {
            // Receiver may not be registered
        }
    }
}
