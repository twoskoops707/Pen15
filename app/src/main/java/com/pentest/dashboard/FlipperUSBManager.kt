package com.pentest.dashboard

import android.app.PendingIntent
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.hardware.usb.UsbDevice
import android.hardware.usb.UsbDeviceConnection
import android.hardware.usb.UsbManager
import android.os.Build
import android.util.Log
import com.hoho.android.usbserial.driver.UsbSerialDriver
import com.hoho.android.usbserial.driver.UsbSerialPort
import com.hoho.android.usbserial.driver.UsbSerialProber
import com.hoho.android.usbserial.util.SerialInputOutputManager
import java.io.IOException
import java.nio.charset.StandardCharsets

/**
 * Proper USB Serial Manager for Flipper Zero using usb-serial-for-android library
 * Based on official mik3y/usb-serial-for-android examples
 */
class FlipperUSBManager(private val context: Context) : SerialInputOutputManager.Listener {

    companion object {
        private const val TAG = "FlipperUSBManager"
        private const val ACTION_USB_PERMISSION = "com.pentest.dashboard.USB_PERMISSION"
        private const val BAUD_RATE = 115200
        private const val DATA_BITS = 8
        private const val STOP_BITS = UsbSerialPort.STOPBITS_1
        private const val PARITY = UsbSerialPort.PARITY_NONE
        private const val WRITE_WAIT_MILLIS = 2000
    }

    private var usbManager: UsbManager = context.getSystemService(Context.USB_SERVICE) as UsbManager
    private var usbSerialPort: UsbSerialPort? = null
    private var usbConnection: UsbDeviceConnection? = null
    private var ioManager: SerialInputOutputManager? = null
    private var connectionListener: ((Boolean, String) -> Unit)? = null
    private var dataReceivedCallback: ((String) -> Unit)? = null

    private var isRpcMode = false

    private val usbPermissionReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context, intent: Intent) {
            if (ACTION_USB_PERMISSION == intent.action) {
                synchronized(this) {
                    val device: UsbDevice? = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                        intent.getParcelableExtra(UsbManager.EXTRA_DEVICE, UsbDevice::class.java)
                    } else {
                        @Suppress("DEPRECATION")
                        intent.getParcelableExtra(UsbManager.EXTRA_DEVICE)
                    }

                    if (intent.getBooleanExtra(UsbManager.EXTRA_PERMISSION_GRANTED, false)) {
                        device?.let {
                            Log.d(TAG, "USB permission granted for device: ${it.deviceName}")
                            connectToDevice(it)
                        }
                    } else {
                        Log.e(TAG, "USB permission denied for device: ${device?.deviceName}")
                        connectionListener?.invoke(false, "USB permission denied")
                    }
                }
            }
        }
    }

    init {
        val filter = IntentFilter(ACTION_USB_PERMISSION)
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            context.registerReceiver(usbPermissionReceiver, filter, Context.RECEIVER_NOT_EXPORTED)
        } else {
            context.registerReceiver(usbPermissionReceiver, filter)
        }
    }

    fun setConnectionListener(listener: (Boolean, String) -> Unit) {
        connectionListener = listener
    }

    fun setDataReceivedCallback(callback: (String) -> Unit) {
        dataReceivedCallback = callback
    }

    /**
     * Find and connect to Flipper Zero device
     */
    fun connect() {
        try {
            val availableDrivers = UsbSerialProber.getDefaultProber().findAllDrivers(usbManager)

            if (availableDrivers.isEmpty()) {
                Log.e(TAG, "No USB devices found")
                connectionListener?.invoke(false, "No USB devices found")
                return
            }

            // Find Flipper Zero device (VID: 0x0483, PID: 0x5740)
            val flipperDriver = availableDrivers.find { driver ->
                val device = driver.device
                device.vendorId == 0x0483 && device.productId == 0x5740
            } ?: availableDrivers.firstOrNull()

            if (flipperDriver == null) {
                Log.e(TAG, "No compatible USB serial drivers found")
                connectionListener?.invoke(false, "No compatible drivers found")
                return
            }

            val device = flipperDriver.device

            // Check if we have permission
            if (!usbManager.hasPermission(device)) {
                Log.d(TAG, "Requesting USB permission for: ${device.deviceName}")
                val permissionIntent = PendingIntent.getBroadcast(
                    context,
                    0,
                    Intent(ACTION_USB_PERMISSION),
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                        PendingIntent.FLAG_MUTABLE
                    } else {
                        0
                    }
                )
                usbManager.requestPermission(device, permissionIntent)
                return
            }

            // We have permission, connect directly
            connectToDevice(device)

        } catch (e: Exception) {
            Log.e(TAG, "Error during connection", e)
            connectionListener?.invoke(false, "Connection error: ${e.message}")
        }
    }

    private fun connectToDevice(device: UsbDevice) {
        try {
            val availableDrivers = UsbSerialProber.getDefaultProber().findAllDrivers(usbManager)
            val driver = availableDrivers.find { it.device == device }

            if (driver == null) {
                Log.e(TAG, "No driver found for device: ${device.deviceName}")
                connectionListener?.invoke(false, "No driver for device")
                return
            }

            usbConnection = usbManager.openDevice(device)
            if (usbConnection == null) {
                Log.e(TAG, "Failed to open device connection")
                connectionListener?.invoke(false, "Failed to open device")
                return
            }

            usbSerialPort = driver.ports[0]
            usbSerialPort?.let { port ->
                try {
                    port.open(usbConnection!!)
                    port.setParameters(BAUD_RATE, DATA_BITS, STOP_BITS, PARITY)

                    Log.d(TAG, "USB Serial Port opened successfully")

                    // Start IO manager for async data reading
                    ioManager = SerialInputOutputManager(port, this)
                    ioManager?.start()

                    // Enter RPC mode for Flipper Zero
                    enterRpcMode()

                    connectionListener?.invoke(true, "Connected to Flipper Zero")

                } catch (e: IOException) {
                    Log.e(TAG, "Error opening port", e)
                    connectionListener?.invoke(false, "Error opening port: ${e.message}")
                    disconnect()
                }
            }

        } catch (e: Exception) {
            Log.e(TAG, "Error connecting to device", e)
            connectionListener?.invoke(false, "Connection failed: ${e.message}")
        }
    }

    /**
     * Enter Flipper Zero RPC mode
     * Protocol: drain buffer -> send "start_rpc_session\r" -> wait for \n confirmation
     */
    private fun enterRpcMode() {
        try {
            // Give the port a moment to stabilize
            Thread.sleep(500)

            // Drain buffer by reading until we see ">: " prompt
            var drainAttempts = 0
            val drainBuffer = ByteArray(1024)
            while (drainAttempts < 10) {
                val read = usbSerialPort?.read(drainBuffer, 100) ?: 0
                if (read > 0) {
                    val data = String(drainBuffer, 0, read, StandardCharsets.UTF_8)
                    Log.d(TAG, "Draining buffer: $data")
                    if (data.contains(">: ")) break
                }
                drainAttempts++
                Thread.sleep(100)
            }

            // Send RPC session start command
            val rpcCommand = "start_rpc_session\r".toByteArray(StandardCharsets.UTF_8)
            usbSerialPort?.write(rpcCommand, WRITE_WAIT_MILLIS)
            Log.d(TAG, "Sent RPC session start command")

            // Wait for confirmation (\n)
            Thread.sleep(200)
            val confirmBuffer = ByteArray(128)
            val read = usbSerialPort?.read(confirmBuffer, 500) ?: 0
            if (read > 0) {
                val response = String(confirmBuffer, 0, read, StandardCharsets.UTF_8)
                Log.d(TAG, "RPC response: $response")
                if (response.contains("\n")) {
                    isRpcMode = true
                    Log.d(TAG, "Successfully entered RPC mode")
                }
            }

        } catch (e: Exception) {
            Log.e(TAG, "Failed to enter RPC mode", e)
        }
    }

    /**
     * Send command to Flipper Zero
     */
    fun sendCommand(command: String) {
        try {
            usbSerialPort?.let { port ->
                val data = "$command\r\n".toByteArray(StandardCharsets.UTF_8)
                port.write(data, WRITE_WAIT_MILLIS)
                Log.d(TAG, "Sent command: $command")
            } ?: run {
                Log.e(TAG, "Cannot send command: port not open")
            }
        } catch (e: IOException) {
            Log.e(TAG, "Error sending command", e)
        }
    }

    /**
     * Disconnect from Flipper Zero
     */
    fun disconnect() {
        try {
            ioManager?.stop()
            ioManager = null

            usbSerialPort?.close()
            usbSerialPort = null

            usbConnection?.close()
            usbConnection = null

            isRpcMode = false

            Log.d(TAG, "Disconnected from Flipper Zero")
            connectionListener?.invoke(false, "Disconnected")

        } catch (e: Exception) {
            Log.e(TAG, "Error during disconnect", e)
        }
    }

    fun isConnected(): Boolean = usbSerialPort?.isOpen == true

    fun cleanup() {
        try {
            disconnect()
            context.unregisterReceiver(usbPermissionReceiver)
        } catch (e: Exception) {
            Log.e(TAG, "Error during cleanup", e)
        }
    }

    // SerialInputOutputManager.Listener callbacks
    override fun onNewData(data: ByteArray) {
        val received = String(data, StandardCharsets.UTF_8)
        Log.d(TAG, "Received data: $received")
        dataReceivedCallback?.invoke(received)
    }

    override fun onRunError(e: Exception) {
        Log.e(TAG, "Serial IO error", e)
        connectionListener?.invoke(false, "IO Error: ${e.message}")
    }
}
