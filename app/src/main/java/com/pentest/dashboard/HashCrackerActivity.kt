package com.pentest.dashboard

import android.os.Bundle
import android.widget.ArrayAdapter
import android.widget.ImageView
import android.widget.ScrollView
import android.widget.Spinner
import android.widget.TextView
import androidx.appcompat.app.AppCompatActivity
import com.google.android.material.button.MaterialButton
import com.google.android.material.textfield.TextInputEditText

class HashCrackerActivity : AppCompatActivity() {

    private lateinit var inputHash: TextInputEditText
    private lateinit var spinnerHashType: Spinner
    private lateinit var spinnerWordlist: Spinner
    private lateinit var logOutput: TextView
    private lateinit var outputScroll: ScrollView
    private lateinit var btnCrackHashcat: MaterialButton
    private lateinit var btnCrackJohn: MaterialButton
    private lateinit var btnIdentifyHash: MaterialButton
    private lateinit var btnStop: MaterialButton

    private val handler = android.os.Handler(android.os.Looper.getMainLooper())
    private var isMonitoring = false

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_hash_cracker)

        // Stop any running processes from other activities
        ProcessManager.stopCurrentProcess(this)

        initializeViews()
        setupClickListeners()
    }

    private fun initializeViews() {
        inputHash = findViewById(R.id.inputHash)
        spinnerHashType = findViewById(R.id.spinnerHashType)
        spinnerWordlist = findViewById(R.id.spinnerWordlist)
        logOutput = findViewById(R.id.logOutput)
        outputScroll = findViewById(R.id.outputScroll)
        btnCrackHashcat = findViewById(R.id.btnCrackHashcat)
        btnCrackJohn = findViewById(R.id.btnCrackJohn)
        btnIdentifyHash = findViewById(R.id.btnIdentifyHash)
        btnStop = findViewById(R.id.btnStop)

        btnStop.isEnabled = false

        // Hash types
        val hashTypes = arrayOf(
            "0 - MD5",
            "100 - SHA1",
            "1000 - NTLM",
            "1400 - SHA256",
            "1700 - SHA512",
            "1800 - sha512crypt",
            "3200 - bcrypt",
            "5600 - NetNTLMv2",
            "13100 - Kerberos 5 TGS-REP",
            "18200 - Kerberos 5 AS-REP"
        )
        spinnerHashType.adapter = ArrayAdapter(this, android.R.layout.simple_spinner_item, hashTypes)

        // Wordlists (ONLINE ONLY - NO LOCAL STORAGE)
        val wordlists = arrayOf(
            "Top 10K passwords (10MB)",
            "Top 100K passwords (100MB)",
            "RockYou (143MB)",
            "Common WiFi passwords (2GB)",
            "Custom URL (enter manually)"
        )
        spinnerWordlist.adapter = ArrayAdapter(this, android.R.layout.simple_spinner_item, wordlists)
    }

    private fun setupClickListeners() {
        findViewById<ImageView>(R.id.btnBack).setOnClickListener {
            ProcessManager.stopCurrentProcess(this)
            finish()
        }

        btnIdentifyHash.setOnClickListener {
            identifyHash()
        }

        btnCrackHashcat.setOnClickListener {
            crackWithHashcat()
        }

        btnCrackJohn.setOnClickListener {
            crackWithJohn()
        }

        btnStop.setOnClickListener {
            stopCracking()
        }
    }

    private fun stopCracking() {
        isMonitoring = false
        ProcessManager.stopCurrentProcess(this)

        addLog("")
        addLog("=== CRACKING STOPPED ===")

        btnCrackHashcat.isEnabled = true
        btnCrackJohn.isEnabled = true
        btnStop.isEnabled = false
    }

    private fun identifyHash() {
        val hash = inputHash.text.toString().trim()
        if (hash.isEmpty()) {
            addLog("ERROR: Please enter a hash")
            return
        }

        addLog("=== HASH IDENTIFICATION ===")
        addLog("Hash: $hash")
        addLog("")

        val length = hash.length
        val identified = when {
            length == 32 && hash.matches(Regex("[a-f0-9]{32}")) -> "Possibly MD5"
            length == 40 && hash.matches(Regex("[a-f0-9]{40}")) -> "Possibly SHA1"
            length == 64 && hash.matches(Regex("[a-f0-9]{64}")) -> "Possibly SHA256"
            length == 128 && hash.matches(Regex("[a-f0-9]{128}")) -> "Possibly SHA512"
            hash.startsWith("${'$'}1${'$'}") -> "MD5 crypt"
            hash.startsWith("${'$'}2a${'$'}") || hash.startsWith("${'$'}2b${'$'}") || hash.startsWith("${'$'}2y${'$'}") -> "bcrypt"
            hash.startsWith("${'$'}6${'$'}") -> "sha512crypt"
            hash.startsWith("${'$'}5${'$'}") -> "sha256crypt"
            else -> "Unknown - check hash length and format"
        }

        addLog("Identified: $identified")
        addLog("")
        addLog("Using hash_identifier command:")
        addLog("echo '$hash' | hash-identifier")
    }

    private fun crackWithHashcat() {
        val hash = inputHash.text.toString().trim()
        if (hash.isEmpty()) {
            addLog("ERROR: Please enter a hash")
            return
        }

        val hashTypeStr = spinnerHashType.selectedItem.toString()
        val hashMode = hashTypeStr.split(" - ")[0]

        val wordlistOption = spinnerWordlist.selectedItemPosition

        // ALL WORDLISTS ARE ONLINE - NO LOCAL STORAGE
        val wordlistUrl = when (wordlistOption) {
            0 -> ParameterDialog.WORDLIST_TOP_10K
            1 -> ParameterDialog.WORDLIST_TOP_100K
            2 -> ParameterDialog.WORDLIST_ROCKYOU
            3 -> ParameterDialog.WORDLIST_WIFI
            else -> "CUSTOM_URL" // User will be prompted to enter URL
        }

        // If custom URL, prompt user for it
        if (wordlistUrl == "CUSTOM_URL") {
            val parameters = listOf(
                ParameterDialog.Parameter(
                    "WORDLIST_URL",
                    "Custom Wordlist URL",
                    "Enter direct URL to wordlist file",
                    required = true
                )
            )

            ParameterDialog(this).showDialog(
                title = "Enter Wordlist URL",
                parameters = parameters
            ) { values ->
                val customUrl = values["WORDLIST_URL"] ?: return@showDialog
                performHashcatCrack(hash, hashMode, customUrl)
            }
            return
        }

        performHashcatCrack(hash, hashMode, wordlistUrl)
    }

    private fun performHashcatCrack(hash: String, hashMode: String, wordlistUrl: String) {

        addLog("=== HASHCAT CRACK ===")
        addLog("Hash: $hash")
        addLog("Mode: $hashMode")
        addLog("Wordlist: ${wordlistUrl.substringAfterLast("/")}")
        addLog("")
        addLog("Streaming wordlist from:")
        addLog(wordlistUrl)
        addLog("")

        // Stream wordlist directly from URL - NO LOCAL STORAGE
        val command = """
            echo "Cracking with hashcat (streaming from online wordlist)..."
            echo '$hash' > /tmp/hash.txt

            # Download and pipe wordlist directly to hashcat
            curl -s '$wordlistUrl' | hashcat -m $hashMode /tmp/hash.txt --stdin --force

            echo ""
            echo "If cracked, run:"
            echo "hashcat -m $hashMode /tmp/hash.txt --show"
        """.trimIndent()

        addLog("Executing hashcat...")
        addLog("")
        addLog("This may take minutes to hours depending on hash complexity and wordlist size.")
        addLog("Wordlist is streamed - NO local storage used!")
        addLog("")

        // Execute via ProcessManager so it can be stopped
        val processId = ProcessManager.startProcess(this, command)
        val scriptFile = java.io.File(getExternalFilesDir(null), "scripts/script_$processId.sh")

        val termux = TermuxIntegration(this)
        termux.runCommand("bash ${scriptFile.absolutePath}", background = false)

        addLog("✓ Process ID: $processId")
        addLog("✓ Hashcat started - Click STOP to terminate")
        addLog("")
        addLog("Output will appear below...")
        addLog("==========================================")

        btnCrackHashcat.isEnabled = false
        btnCrackJohn.isEnabled = false
        btnStop.isEnabled = true

        // Start monitoring output
        startOutputMonitoring()
    }

    private fun crackWithJohn() {
        val hash = inputHash.text.toString().trim()
        if (hash.isEmpty()) {
            addLog("ERROR: Please enter a hash")
            return
        }

        val wordlistOption = spinnerWordlist.selectedItemPosition

        // ALL WORDLISTS ARE ONLINE - NO LOCAL STORAGE
        val wordlistUrl = when (wordlistOption) {
            0 -> ParameterDialog.WORDLIST_TOP_10K
            1 -> ParameterDialog.WORDLIST_TOP_100K
            2 -> ParameterDialog.WORDLIST_ROCKYOU
            3 -> ParameterDialog.WORDLIST_WIFI
            else -> "CUSTOM_URL"
        }

        // If custom URL, prompt user for it
        if (wordlistUrl == "CUSTOM_URL") {
            val parameters = listOf(
                ParameterDialog.Parameter(
                    "WORDLIST_URL",
                    "Custom Wordlist URL",
                    "Enter direct URL to wordlist file",
                    required = true
                )
            )

            ParameterDialog(this).showDialog(
                title = "Enter Wordlist URL",
                parameters = parameters
            ) { values ->
                val customUrl = values["WORDLIST_URL"] ?: return@showDialog
                performJohnCrack(hash, customUrl)
            }
            return
        }

        performJohnCrack(hash, wordlistUrl)
    }

    private fun performJohnCrack(hash: String, wordlistUrl: String) {
        addLog("=== JOHN THE RIPPER ===")
        addLog("Hash: $hash")
        addLog("Wordlist: ${wordlistUrl.substringAfterLast("/")}")
        addLog("")
        addLog("Streaming wordlist from:")
        addLog(wordlistUrl)
        addLog("")

        // Stream wordlist directly from URL - NO LOCAL STORAGE
        val command = """
            echo "Cracking with John the Ripper (streaming from online wordlist)..."
            echo '$hash' > /tmp/hash.txt

            # Download wordlist to temp and pipe to john
            curl -s '$wordlistUrl' | john --stdin /tmp/hash.txt

            echo ""
            echo "Show cracked passwords:"
            john --show /tmp/hash.txt
        """.trimIndent()

        addLog("Executing John the Ripper...")
        addLog("")
        addLog("John will auto-detect hash type.")
        addLog("Wordlist is streamed - NO local storage used!")
        addLog("")

        // Execute via ProcessManager so it can be stopped
        val processId = ProcessManager.startProcess(this, command)
        val scriptFile = java.io.File(getExternalFilesDir(null), "scripts/script_$processId.sh")

        val termux = TermuxIntegration(this)
        termux.runCommand("bash ${scriptFile.absolutePath}", background = false)

        addLog("✓ Process ID: $processId")
        addLog("✓ John started - Click STOP to terminate")
        addLog("")
        addLog("Output will appear below...")
        addLog("==========================================")

        btnCrackHashcat.isEnabled = false
        btnCrackJohn.isEnabled = false
        btnStop.isEnabled = true

        // Start monitoring output
        startOutputMonitoring()
    }

    private fun addLog(message: String) {
        val timestamp = java.text.SimpleDateFormat("HH:mm:ss", java.util.Locale.US)
            .format(java.util.Date())
        val currentLog = logOutput.text.toString()
        logOutput.text = "[$timestamp] $message\n$currentLog"

        outputScroll.post {
            outputScroll.fullScroll(ScrollView.FOCUS_DOWN)
        }
    }

    private fun startOutputMonitoring() {
        isMonitoring = true

        val monitorRunnable = object : Runnable {
            override fun run() {
                if (!isMonitoring) return

                val outputFile = ProcessManager.getOutputFile(this@HashCrackerActivity)
                if (outputFile?.exists() == true) {
                    val output = outputFile.readText()
                    runOnUiThread {
                        // Show REAL output from hashcat/john
                        logOutput.text = output
                        outputScroll.post {
                            outputScroll.fullScroll(ScrollView.FOCUS_DOWN)
                        }
                    }
                }

                // Check if process still running
                if (!ProcessManager.isProcessRunning(this@HashCrackerActivity)) {
                    isMonitoring = false
                    runOnUiThread {
                        btnCrackHashcat.isEnabled = true
                        btnCrackJohn.isEnabled = true
                        btnStop.isEnabled = false
                        addLog("")
                        addLog("=== CRACKING COMPLETE ===")
                        addLog("Check output above for cracked password!")
                    }
                    return
                }

                handler.postDelayed(this, 1000) // Update every second
            }
        }

        handler.post(monitorRunnable)
    }

    override fun onPause() {
        super.onPause()
        ProcessManager.stopCurrentProcess(this)
        isMonitoring = false
    }

    override fun onDestroy() {
        super.onDestroy()
        ProcessManager.stopCurrentProcess(this)
        isMonitoring = false
    }
}
