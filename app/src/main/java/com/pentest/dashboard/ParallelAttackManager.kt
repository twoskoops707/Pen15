package com.pentest.dashboard

import android.os.Handler
import android.os.Looper
import java.util.concurrent.ConcurrentHashMap

/**
 * Parallel Attack Manager
 *
 * Allows running multiple attacks simultaneously:
 * - Flipper Zero native attacks
 * - ESP32 Marauder WiFi attacks
 * - Sub-GHz attacks
 * - BadUSB payloads
 *
 * Example: Run WiFi deauth (Marauder) + Sub-GHz brute force (Flipper) at the same time
 */
class ParallelAttackManager {

    data class Attack(
        val id: String,
        val name: String,
        val type: AttackType,
        val device: Device,
        var status: AttackStatus,
        val startTime: Long = System.currentTimeMillis(),
        var logOutput: String = ""
    )

    enum class AttackType {
        WIFI_DEAUTH,
        WIFI_EVIL_PORTAL,
        BLE_SPAM,
        SUBGHZ_BRUTEFORCE,
        SUBGHZ_REPLAY,
        RFID_BRUTEFORCE,
        RFID_ROLLING_CODE,
        NFC_REPLAY,
        BADUSB_PAYLOAD,
        IR_BLAST
    }

    enum class Device {
        FLIPPER_ZERO,
        ESP32_MARAUDER,
        BOTH
    }

    enum class AttackStatus {
        RUNNING,
        PAUSED,
        STOPPED,
        COMPLETED,
        FAILED
    }

    private val activeAttacks = ConcurrentHashMap<String, Attack>()
    private val handler = Handler(Looper.getMainLooper())
    private var statusCallback: ((List<Attack>) -> Unit)? = null

    /**
     * Start a new attack
     */
    fun startAttack(name: String, type: AttackType, device: Device): String {
        val attackId = generateAttackId()
        val attack = Attack(
            id = attackId,
            name = name,
            type = type,
            device = device,
            status = AttackStatus.RUNNING
        )

        activeAttacks[attackId] = attack
        notifyStatusChange()

        return attackId
    }

    /**
     * Stop a running attack
     */
    fun stopAttack(attackId: String) {
        activeAttacks[attackId]?.let { attack ->
            attack.status = AttackStatus.STOPPED
            notifyStatusChange()

            // Remove after 5 seconds
            handler.postDelayed({
                activeAttacks.remove(attackId)
                notifyStatusChange()
            }, 5000)
        }
    }

    /**
     * Pause an attack
     */
    fun pauseAttack(attackId: String) {
        activeAttacks[attackId]?.let { attack ->
            attack.status = AttackStatus.PAUSED
            notifyStatusChange()
        }
    }

    /**
     * Resume a paused attack
     */
    fun resumeAttack(attackId: String) {
        activeAttacks[attackId]?.let { attack ->
            attack.status = AttackStatus.RUNNING
            notifyStatusChange()
        }
    }

    /**
     * Update attack log output
     */
    fun updateAttackLog(attackId: String, log: String) {
        activeAttacks[attackId]?.let { attack ->
            attack.logOutput = log
            notifyStatusChange()
        }
    }

    /**
     * Mark attack as completed
     */
    fun completeAttack(attackId: String) {
        activeAttacks[attackId]?.let { attack ->
            attack.status = AttackStatus.COMPLETED
            notifyStatusChange()

            // Remove after 10 seconds
            handler.postDelayed({
                activeAttacks.remove(attackId)
                notifyStatusChange()
            }, 10000)
        }
    }

    /**
     * Get all active attacks
     */
    fun getActiveAttacks(): List<Attack> {
        return activeAttacks.values.toList()
    }

    /**
     * Get running attacks count
     */
    fun getRunningCount(): Int {
        return activeAttacks.values.count { it.status == AttackStatus.RUNNING }
    }

    /**
     * Check if specific device is currently in use
     */
    fun isDeviceBusy(device: Device): Boolean {
        return activeAttacks.values.any {
            it.status == AttackStatus.RUNNING &&
            (it.device == device || it.device == Device.BOTH || device == Device.BOTH)
        }
    }

    /**
     * Stop all attacks
     */
    fun stopAllAttacks() {
        activeAttacks.values.forEach { attack ->
            attack.status = AttackStatus.STOPPED
        }
        notifyStatusChange()

        handler.postDelayed({
            activeAttacks.clear()
            notifyStatusChange()
        }, 5000)
    }

    /**
     * Set callback for status changes
     */
    fun setStatusCallback(callback: (List<Attack>) -> Unit) {
        statusCallback = callback
    }

    private fun notifyStatusChange() {
        handler.post {
            statusCallback?.invoke(getActiveAttacks())
        }
    }

    private fun generateAttackId(): String {
        return "ATK_${System.currentTimeMillis()}_${(1000..9999).random()}"
    }

    /**
     * Preset Attack Configurations
     */
    object Presets {
        fun dualDeauth(): List<Pair<String, AttackType>> {
            return listOf(
                "Flipper Deauth" to AttackType.SUBGHZ_REPLAY,
                "Marauder Deauth" to AttackType.WIFI_DEAUTH
            )
        }

        fun fullSpectrum(): List<Pair<String, AttackType>> {
            return listOf(
                "Sub-GHz Scan" to AttackType.SUBGHZ_BRUTEFORCE,
                "WiFi Deauth" to AttackType.WIFI_DEAUTH,
                "BLE Spam" to AttackType.BLE_SPAM
            )
        }

        fun accessControl(): List<Pair<String, AttackType>> {
            return listOf(
                "RFID Brute" to AttackType.RFID_BRUTEFORCE,
                "NFC Clone" to AttackType.NFC_REPLAY
            )
        }
    }
}
